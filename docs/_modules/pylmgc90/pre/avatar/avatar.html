
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pylmgc90.pre.avatar.avatar &#8212; pylmgc90 2025.rc1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinxdoc.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pylmgc90 2025.rc1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pylmgc90.pre.avatar.avatar</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pylmgc90.pre.avatar.avatar</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="k">try</span><span class="p">:</span>
  <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
  <span class="n">plt</span> <span class="o">=</span> <span class="kc">None</span>

<span class="kn">from</span> <span class="nn">.nodes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.bulks</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.bulk.rigid2d</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.bulk.rigid3d</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.bulk.element</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.contactors</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.groups</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.group</span> <span class="kn">import</span> <span class="n">group</span>
<span class="kn">from</span> <span class="nn">..config.lmgc90dicts</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">..utilities.error</span>    <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># pour la verification des types (modele et materiau)</span>
<span class="kn">from</span> <span class="nn">..shared.bulk_behav</span> <span class="kn">import</span> <span class="n">material</span> <span class="k">as</span> <span class="n">class_material</span>
<span class="kn">from</span> <span class="nn">..shared.model</span> <span class="kn">import</span> <span class="n">model</span> <span class="k">as</span> <span class="n">class_model</span>

<span class="kn">from</span> <span class="nn">.contactor.contactorFactory</span> <span class="kn">import</span> <span class="n">contactorFactory</span>

<span class="kn">from</span> <span class="nn">..build_avatar.mesh</span> <span class="kn">import</span> <span class="n">mesh</span> <span class="k">as</span> <span class="n">class_mesh</span>

<span class="c1">## @class avatar</span>
<span class="c1"># attributs:  \n</span>
<span class="c1">#   atype is a string describing the numerical spatial discretization\n</span>
<span class="c1">#   nodes is a node iterator with number as key\n</span>
<span class="c1">#   bulks is a bulk iterator with number as key\n</span>
<span class="c1">#   contactors is a contactor iterator with number as key\n</span>
<span class="c1">#   groups is a group iterator with number as key\n</span>
<div class="viewcode-block" id="avatar"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar">[docs]</a><span class="k">class</span> <span class="nc">avatar</span><span class="p">():</span>

    <span class="c1">## constructor</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;__init__(self, dimension, number=None):</span>

<span class="sd">        allow to define an avatar</span>

<span class="sd">        parameters:</span>

<span class="sd">        - self: the avatar itself</span>
<span class="sd">        - dimension: spatial dimension (2, in 2D, 3 in 3D)</span>

<span class="sd">        optional parameters:</span>

<span class="sd">        - number=None: index of the avatar (still present to ensure compatibility)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># si l&#39;utilisateur attribue un numero a l&#39;avatar</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
           <span class="c1"># on lui indique qu&#39;il ne sera pas utilise</span>
           <span class="n">showWarning</span><span class="p">(</span><span class="s1">&#39;assign an index to an avatar is useless, and will be forbidden!&#39;</span><span class="p">)</span>
        <span class="c1"># le numero de l&#39;avatar est inconnu pour l&#39;instant et sera defini lors de son</span>
        <span class="c1"># ajout dans un container d&#39;avatar (et eventuellement modifie, suite au passage dans</span>
        <span class="c1"># un nouveau container)</span>
        <span class="c1"># number is a numbering by avatar type (rigid or mesh)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># m_num is a numbering by physic type (mecaMAILx, therMAILx, etc)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_num</span>  <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">atype</span>  <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># am : ajout de la notion de dimension, pour la gestion des mailles</span>
        <span class="c1"># si la dimension est impossible</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">dimension</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">dimension</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;spatial dimension must be 2 (in 2D) or 3 (in 3D)!&quot;</span><span class="p">)</span>

        <span class="c1"># si tous les tests sur la dimension ont reussi, on la stocke</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span> <span class="o">=</span> <span class="n">bulks</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contactors</span> <span class="o">=</span> <span class="n">contactors</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">=</span> <span class="n">groups</span><span class="p">()</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modelType</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drvDof</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iniDof</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iniGpv</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1">## add one node</span>
    <span class="c1"># @arg Noeud a node </span>
<div class="viewcode-block" id="avatar.addNode"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.addNode">[docs]</a>    <span class="k">def</span> <span class="nf">addNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Noeud</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Usage : avatar.addNode(noeud)</span>

<span class="sd">        where noeud is a node object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># test paranoiaque de la dimension </span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">Noeud</span><span class="o">.</span><span class="n">coor</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
           <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">Noeud</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;incompatible size between coor array and dimension&#39;</span><span class="p">)</span></div>

    <span class="c1">## add nodes of an iterator</span>
    <span class="c1"># @arg Noeuds node iterator</span>
<div class="viewcode-block" id="avatar.addNodes"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.addNodes">[docs]</a>    <span class="k">def</span> <span class="nf">addNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Noeuds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Usage : avatar.addNodes(noeuds)</span>

<span class="sd">        where noeuds is a node iterator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">Noeud</span> <span class="ow">in</span> <span class="n">Noeuds</span><span class="p">:</span>
           <span class="bp">self</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">Noeud</span><span class="p">)</span></div>
       
    <span class="c1">## add one bulk</span>
    <span class="c1"># @arg Ele a bulk</span>
    <span class="c1"># @todo : check that bulk type matches avatar type</span>
<div class="viewcode-block" id="avatar.addBulk"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.addBulk">[docs]</a>    <span class="k">def</span> <span class="nf">addBulk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Ele</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Usage : avatar.addBulk(Ele)</span>

<span class="sd">        where Ele is a bulk</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># on attribue au bulk le numero du prochain bulk</span>
        <span class="c1"># de l&#39;avatar</span>
        <span class="c1"># N.B.: - la numerotation commence a 0</span>
        <span class="c1">#       - le numero d&#39;un bulk est confondu avec son </span>
        <span class="c1">#       indice dans le container de bulks attache a </span>
        <span class="c1">#       l&#39;avatar auquel il appartient</span>
        <span class="n">Ele</span><span class="o">.</span><span class="n">number</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">)</span>
        <span class="c1"># on l&#39;ajoute dans le container de bulks de l&#39;avatar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span><span class="n">Ele</span><span class="p">)</span>
       
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Ele</span><span class="p">,</span><span class="n">rigid2d</span><span class="p">):</span>

          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;Trying to assign a rigid 2D element to a 3D avatar!&quot;</span><span class="p">)</span>

          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">=</span> <span class="s1">&#39;RBDY2&#39;</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span><span class="o">==</span><span class="s1">&#39;MAILx&#39;</span><span class="p">:</span>
              <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;Trying to assign a rigid 2D element to a meshed avatar!&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Ele</span><span class="p">,</span><span class="n">rigid3d</span><span class="p">):</span>

          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;Trying to assign a rigid 3D element to a 2D avatar!&quot;</span><span class="p">)</span>

          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">=</span> <span class="s1">&#39;RBDY3&#39;</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span><span class="o">==</span><span class="s1">&#39;MAILx&#39;</span><span class="p">:</span>
              <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;Trying to assign a rigid 3D element to a meshed avatar!&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Ele</span><span class="p">,</span><span class="n">element</span><span class="p">):</span>

          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">=</span> <span class="s1">&#39;MAILx&#39;</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span><span class="o">!=</span><span class="s1">&#39;MAILx&#39;</span><span class="p">:</span>
              <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;Trying to assign a finite element to a rigid avatar!&quot;</span><span class="p">)</span></div>

    <span class="c1">## add bulks of an iterator</span>
    <span class="c1"># @arg Eles bulks iterator</span>
<div class="viewcode-block" id="avatar.addBulks"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.addBulks">[docs]</a>    <span class="k">def</span> <span class="nf">addBulks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Eles</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Usage : avatar.addBulks(Eles)</span>

<span class="sd">        where Eles is a bulk iterator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">Ele</span> <span class="ow">in</span> <span class="n">Eles</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span><span class="n">Ele</span><span class="p">)</span></div>

    <span class="c1"># methode privee ajoute un contacteur a l&#39;avatar, en lui affectant un numero</span>
    <span class="k">def</span> <span class="nf">_addContactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tact</span><span class="p">):</span>
       <span class="sd">&quot;&quot;&quot;_addContactor(self, tact):</span>

<span class="sd">       this private method adds a contactor to the contactors container </span>
<span class="sd">       attached to the avatar</span>

<span class="sd">       parameters:</span>

<span class="sd">       - self: the avatar itself</span>
<span class="sd">       - tact: the new contactor to be added</span>
<span class="sd">       &quot;&quot;&quot;</span>
       <span class="c1"># on attribue au contacteur le numero du prochain contacteur</span>
       <span class="c1"># de l&#39;avatar</span>
       <span class="c1"># N.B.: - la numerotation commence a 0</span>
       <span class="c1">#       - le numero d&#39;un contacteur est confondu avec son </span>
       <span class="c1">#       indice dans le container de contacteurs attache a </span>
       <span class="c1">#       l&#39;avatar auquel il appartient</span>
       <span class="n">tact</span><span class="o">.</span><span class="n">number</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">)</span>
       <span class="c1"># on l&#39;ajoute dans le container de contacteurs de l&#39;avatar</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="o">.</span><span class="n">addContactor</span><span class="p">(</span><span class="n">tact</span><span class="p">)</span>
      
    <span class="c1"># methode qui calcule les proprietes specifiques d&#39;un corps rigide : masse, inertie et position du centre de gravite</span>
<div class="viewcode-block" id="avatar.computeRigidProperties"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.computeRigidProperties">[docs]</a>    <span class="k">def</span> <span class="nf">computeRigidProperties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="sd">&quot;&quot;&quot;computeRigidProperties(self):</span>

<span class="sd">       this function computes rigid properties of a rigid avatar : mass, inertia and mass center, from the contactors</span>

<span class="sd">       parameters:</span>

<span class="sd">       - self: the avatar itself</span>
<span class="sd">       &quot;&quot;&quot;</span>
        
       <span class="c1"># si l&#39;avatar n&#39;est pas rigide</span>
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">!=</span> <span class="s1">&#39;RBDY2&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">!=</span> <span class="s1">&#39;RBDY3&#39;</span><span class="p">:</span>
          <span class="c1"># il n&#39;est pas concerne par cette fonction</span>
          <span class="n">showWarning</span><span class="p">(</span><span class="s2">&quot;skipping deformable body&quot;</span><span class="p">)</span>
          <span class="c1"># on quitte la fonction</span>
          <span class="k">return</span>

       <span class="c1"># si l&#39;avatar n&#39;a pas son bulk</span>
       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="c1"># on ne peut pas encore calculer les proprietes du rigide</span>
          <span class="n">showWarning</span><span class="p">(</span><span class="s2">&quot;this avatar missing its bulk, skipping&quot;</span><span class="p">)</span>
          <span class="c1"># on quitte la fonction</span>
          <span class="k">return</span>

       <span class="c1"># si l&#39;avatar n&#39;a pas encore son noeud</span>
       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="c1"># on ne peut pas encore calculer les proprietes du rigide</span>
          <span class="n">showWarning</span><span class="p">(</span><span class="s2">&quot;this avatar missing its node, skipping&quot;</span><span class="p">)</span>
          <span class="c1"># on quitte la fonction</span>
          <span class="k">return</span>
          
       <span class="c1"># si l&#39;avatar n&#39;a pas de contacteurs</span>
       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="c1"># on ne peut pas encore calculer les proprietes du rigide</span>
          <span class="n">showWarning</span><span class="p">(</span><span class="s2">&quot;this avatar missing contactors, skipping&quot;</span><span class="p">)</span>
          <span class="c1"># on quitte la fonction</span>
          <span class="k">return</span>

       <span class="c1"># ici, on a affaire a un rigide bien defini</span>

       <span class="c1"># si l&#39;avatar est un rigide 2D</span>
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">==</span> <span class="s1">&#39;RBDY2&#39;</span><span class="p">:</span>
          <span class="c1"># on cherche si on doit recalculer la position du centre d&#39;inertie</span>

          <span class="c1"># on suppose initialement qu&#39;il n&#39;y a pas a la recalculer</span>
          <span class="n">comp_node</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="c1"># si la position du centre d&#39;inertie est nulle</span>
          <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coor</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
             <span class="c1"># on indique qu&#39;on va devoir la recalculer</span>
             <span class="n">comp_node</span> <span class="o">=</span> <span class="kc">True</span> 

          <span class="c1"># si l&#39;avatar ne porte qu&#39;un seul contacteur</span>
          <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
             <span class="c1"># si on ne doit par recacluler la position du centre d&#39;inertie,</span>
             <span class="c1"># mais que le shift du contacteur est non nul</span>
             <span class="k">if</span> <span class="ow">not</span> <span class="n">comp_node</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
                <span class="c1">#fd</span>
                <span class="c1">#fd on est dans un cas non gere car si cooref /= (0.,0.) alors OG = (0. 0.) (i.e. le shift)</span>
                <span class="c1">#fd</span>
                <span class="n">msg</span>  <span class="o">=</span> <span class="s2">&quot;Beware, concerning RBDY2 numbered &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;The vertices were defined in the inertia frame but ||OG|| /= 0 &quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;The vertices should be defined either:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  in the inertia frame</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  or in the absolute frame&quot;</span>
                <span class="n">showError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
             <span class="c1"># sinon,</span>
             <span class="c1">#fd</span>
             <span class="c1">#fd on est dans le cas ou on a volontairement decrit les vertex dans le repere </span>
             <span class="c1">#fd absolu et pas dans le repere barycentrique</span>
             <span class="c1">#fd</span>

             <span class="c1"># si le seul contacteur porte par l&#39;objet est un point</span>
             <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="s1">&#39;PT2Dx&#39;</span><span class="p">:</span>
                <span class="c1"># on indique que ca n&#39;a pas de sens</span>
                <span class="n">msg</span>  <span class="o">=</span> <span class="s2">&quot;Beware, concerning RBDY2 numbered &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;There is only a point type contactor</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;This contactore does not allow to compute the surface and the inertial of the object</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;At least another contactor should be added to ask for the automatic computation</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;of the mass and the inertia of the object!&quot;</span> 
                <span class="n">showError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

          <span class="c1"># on calcule la surface totale de l&#39;avatar</span>
          <span class="c1"># on initialise la surface totale a 0</span>
          <span class="n">area</span> <span class="o">=</span> <span class="mf">0.</span>
          <span class="c1"># pour chaque contacteur</span>
          <span class="k">for</span> <span class="n">tact</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">:</span>
             <span class="c1"># on ajoute la contribution du contacteur courant</span>
             <span class="n">area</span> <span class="o">+=</span> <span class="n">tact</span><span class="o">.</span><span class="n">area</span>

          <span class="c1"># si la surface calculee est nulle</span>
          <span class="k">if</span> <span class="n">area</span> <span class="o">&lt;=</span> <span class="mf">1e-14</span><span class="p">:</span>
             <span class="c1"># on est dans le cas d&#39;un contacteur special qui n&#39;a pas de surface</span>
             <span class="c1"># e.g. disque creux ou point 2D, et le calcul d&#39;un centre d&#39;inertie</span>
             <span class="c1"># ou de inertie n&#39;ont pas de sens</span>

             <span class="c1">#  on fixe l&#39;avrd et le gyrd a 0.</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">avrd</span> <span class="o">=</span> <span class="mf">0.</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">gyrd</span> <span class="o">=</span> <span class="mf">0.</span>
             <span class="c1"># on quitte la fonction</span>
             <span class="k">return</span>

          <span class="c1"># ici, on est sur que le corps a une surface non nulle</span>

          <span class="c1"># on en deduit l&#39;avrd</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">avrd</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">area</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

          <span class="c1">#fd</span>
          <span class="c1">#fd si necessaire on recalcule le centre d&#39;inertie et on corrige le shift</span>
          <span class="c1">#fd</span>
          <span class="k">if</span> <span class="n">comp_node</span><span class="p">:</span>
             <span class="c1"># on calcule la postion du centre d&#39;inertie a partir des shifts</span>
             <span class="c1"># on initialise la position du centre d&#39;inertie a O</span>
             <span class="n">OG</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
             <span class="c1"># pour chaque contacteur</span>
             <span class="k">for</span> <span class="n">tact</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">:</span>
                <span class="c1"># on ajoute la contribution du contacteur courant</span>
                <span class="n">OG</span> <span class="o">+=</span> <span class="n">tact</span><span class="o">.</span><span class="n">area</span><span class="o">*</span><span class="n">tact</span><span class="o">.</span><span class="n">shift</span>
             <span class="c1"># on divise par la surface totale pour obtenir la position du centre d&#39;inertie</span>
             <span class="n">OG</span> <span class="o">=</span> <span class="n">OG</span><span class="o">/</span><span class="n">area</span>

             <span class="c1"># on corrige les shifts</span>
             <span class="c1"># pour chaque contacteur</span>
             <span class="k">for</span> <span class="n">tact</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">:</span>
                <span class="c1"># on corrige le shift du contacteur courant</span>
                <span class="n">tact</span><span class="o">.</span><span class="n">shift</span> <span class="o">-=</span> <span class="n">OG</span>

             <span class="c1"># on stocke la position du centre d&#39;inertie</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coor</span> <span class="o">=</span> <span class="n">OG</span> 

          <span class="c1"># on recalcule l&#39;inertie du corps</span>

          <span class="c1"># on initialise l&#39;inertie totale a 0</span>
          <span class="n">I</span> <span class="o">=</span> <span class="mf">0.</span>
          <span class="c1"># pour chaque contacteur</span>
          <span class="k">for</span> <span class="n">tact</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">:</span>
             <span class="c1"># on calcule le carre de la norme du shift du contacteur courant</span>
             <span class="n">d2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tact</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="n">tact</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span>
             <span class="c1"># on ajoute la contribution du contacteur courant (formule de Huygens)</span>
             <span class="n">I</span> <span class="o">+=</span> <span class="n">tact</span><span class="o">.</span><span class="n">I</span> <span class="o">+</span> <span class="n">tact</span><span class="o">.</span><span class="n">area</span><span class="o">*</span><span class="n">d2</span>
   
          <span class="c1"># on en deduit le gyrd</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">gyrd</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">I</span><span class="o">/</span><span class="n">area</span><span class="p">)</span>

       <span class="c1"># si l&#39;avatar est un rigide 3D</span>
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">==</span> <span class="s1">&#39;RBDY3&#39;</span><span class="p">:</span>
          <span class="c1"># on cherche si on doit recalculer la position du centre d&#39;inertie</span>

          <span class="c1"># on suppose initialement qu&#39;il n&#39;y a pas a la recalculer</span>
          <span class="n">comp_node</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="c1"># si la position du centre d&#39;inertie est nulle</span>
          <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coor</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
             <span class="c1"># on indique qu&#39;on va devoir la recalculer</span>
             <span class="n">comp_node</span> <span class="o">=</span> <span class="kc">True</span> 

          <span class="c1"># si l&#39;avatar ne porte qu&#39;un seul contacteur</span>
          <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
             <span class="c1"># si on ne doit par recalculer la position du centre d&#39;inertie,</span>
             <span class="c1"># mais que le shift du contacteur est non nul</span>
             <span class="k">if</span> <span class="ow">not</span> <span class="n">comp_node</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
                <span class="c1"># on est dans un cas non gere car si cooref /= (0., 0., 0.) alors OG = (0., 0., 0.) (i.e. le shift)</span>
                <span class="n">msg</span>  <span class="o">=</span> <span class="s2">&quot;Beware, concerning RBDY3 numbered &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;The vertices were defined in the inertia frame but ||OG|| /= 0 &quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;The vertices should be defined either:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  in the inertia frame</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  or in the absolute frame&quot;</span>
                <span class="n">showError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
             <span class="c1"># sinon, on est dans le cas ou on a volontairement decrit les vertex dans le repere </span>
             <span class="c1"># absolu et pas dans le repere barycentrique</span>

             <span class="c1"># si le seul contacteur porte par l&#39;objet est un point</span>
             <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="s1">&#39;PT3Dx&#39;</span><span class="p">:</span>
                <span class="n">msg</span>  <span class="o">=</span> <span class="s2">&quot;Beware, concerning RBDY3 numbered &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;There is only a point type contactor</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;This contactore does not allow to compute the surface and the inertial of the object</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;At least another contactor should be added to ask for the automatic computation</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;of the mass and the inertia of the object!&quot;</span> 
                <span class="n">showError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

          <span class="c1"># on calcule le volume totale de l&#39;avatar</span>
          <span class="c1"># on initialise le volume total a 0</span>
          <span class="n">volume</span> <span class="o">=</span> <span class="mf">0.</span>
          <span class="c1"># pour chaque contacteur</span>
          <span class="k">for</span> <span class="n">tact</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">:</span>
             <span class="c1"># on ajoute la contribution du contacteur courant</span>
             <span class="n">volume</span> <span class="o">+=</span> <span class="n">tact</span><span class="o">.</span><span class="n">volume</span>

          <span class="c1"># on en deduit l&#39;avrd</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">avrd</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">0.75</span><span class="o">*</span><span class="n">volume</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span>

          <span class="c1"># si necessaire on recalcule le centre d&#39;inertie et on corrige le shift</span>
          <span class="k">if</span> <span class="n">comp_node</span><span class="p">:</span>
             <span class="c1"># on calcule la postion du centre d&#39;inertie a partir des shifts</span>
             <span class="c1"># on initialise la position du centre d&#39;inertie a O</span>
             <span class="n">OG</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
             <span class="c1"># pour chaque contacteur</span>
             <span class="k">for</span> <span class="n">tact</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">:</span>
                <span class="c1"># on ajoute la contribution du contacteur courant</span>
                <span class="n">OG</span> <span class="o">+=</span> <span class="n">tact</span><span class="o">.</span><span class="n">volume</span><span class="o">*</span><span class="n">tact</span><span class="o">.</span><span class="n">shift</span>
             <span class="c1"># on divise par le volume total pour obtenir la position du centre d&#39;inertie</span>
             <span class="n">OG</span> <span class="o">=</span> <span class="n">OG</span><span class="o">/</span><span class="n">volume</span>

             <span class="c1"># on corrige les shifts</span>
             <span class="c1"># pour chaque contacteur</span>
             <span class="k">for</span> <span class="n">tact</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">:</span>
                <span class="c1"># on corrige le shift du contacteur courant</span>
                <span class="n">tact</span><span class="o">.</span><span class="n">shift</span> <span class="o">-=</span> <span class="n">OG</span>

             <span class="c1"># on stocke la position du centre d&#39;inertie</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coor</span> <span class="o">=</span> <span class="n">OG</span> 

          <span class="c1"># on recalcule l&#39;inertie du corps</span>

          <span class="c1"># on initialise l&#39;inertie totale a la matrice nulle</span>
          <span class="n">I</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
          <span class="c1"># pour chaque contacteur</span>
          <span class="k">for</span> <span class="n">tact</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">:</span>
             <span class="c1"># assemblage des contributions des tactors inertie + vol*distance_axe  </span>
   
             <span class="c1"># on ajoute l&#39;inertie du contacteur courant a l&#39;inertie totale</span>
             <span class="n">I</span> <span class="o">+=</span> <span class="n">tact</span><span class="o">.</span><span class="n">I</span>
   
             <span class="c1"># contribution de la distance a l&#39;axe aux termes diagonaux</span>
             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tact</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span>
                <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tact</span><span class="o">.</span><span class="n">volume</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
   
             <span class="c1"># contribution de la distance a l&#39;axe aux termes extra-diagonaux</span>
             <span class="n">d</span> <span class="o">=</span> <span class="n">tact</span><span class="o">.</span><span class="n">shift</span>
             <span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">tact</span><span class="o">.</span><span class="n">volume</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
             <span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">tact</span><span class="o">.</span><span class="n">volume</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
             <span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">tact</span><span class="o">.</span><span class="n">volume</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
             <span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">tact</span><span class="o">.</span><span class="n">volume</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
             <span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">tact</span><span class="o">.</span><span class="n">volume</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
             <span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">tact</span><span class="o">.</span><span class="n">volume</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
   
          <span class="c1"># diagonalisation de la matrice d&#39;inertie</span>
   
          <span class="c1"># nettoyage de la matrice :</span>
   
          <span class="c1"># on initialise le nombre de termes au-dessus de la diagonale annulles</span>
          <span class="n">nb</span><span class="o">=</span><span class="mi">0</span>
          <span class="c1"># pour chaque ligne</span>
          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
             <span class="c1"># pour chaque terme au-dessus de la diagonale</span>
             <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="c1"># si le terme extra-diagonal courant est negligeable devant le terme</span>
                <span class="c1"># diagonal courant</span>
                <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1.e-14</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]):</span> 
                   <span class="c1"># on incremente le nombre de termes au-dessus de la diagonale</span>
                   <span class="c1"># annulles</span>
                   <span class="n">nb</span> <span class="o">+=</span> <span class="mi">1</span>
                   <span class="c1"># on annule le terme extra-diagonal au-dessus de la diagonale</span>
                   <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mf">0.e0</span>
                   <span class="c1"># et le terme extra-diagonal au-dessous de la diagonale (matrice</span>
                   <span class="c1"># symetrique)</span>
                   <span class="n">I</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mf">0.e0</span>
          
          <span class="c1"># diagonalisation de la matrice</span>
          
          <span class="c1"># si la matrice &quot;nettoyee&quot; est deja diagonale</span>
          <span class="k">if</span> <span class="n">nb</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
             <span class="c1"># on obtient immediatement les valeurs propres (valeurs diagonales)</span>
             <span class="n">I_diag</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">])</span>
             <span class="c1"># et la matrice de passage (matrice identite)</span>
             <span class="n">P</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
          <span class="c1"># sinon,</span>
          <span class="k">else</span><span class="p">:</span>
             <span class="c1"># on appelle la routine de calcul des valeurs propres et vecteurs propres</span>
             <span class="c1"># disponible dans scipy </span>
             <span class="n">I_diag</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> 
             <span class="c1"># on s&#39;assure que le repere est direct en recalculant la troisieme direction</span>
             <span class="c1"># comme le produit vectoriel des deux premieres</span>
             <span class="n">P</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">P</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">P</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
   
          <span class="c1"># on stocke les inerties principales</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">setInertia</span><span class="p">(</span><span class="n">I_diag</span><span class="p">)</span>
    
          <span class="c1"># on stocke le repere principal d&#39;inertie</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">setFrame</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
  
          <span class="c1"># on impose une condition initiale bidon (vitesse initiale nulle), pour</span>
          <span class="c1"># forcer l&#39;ecriture du repere de l&#39;objet dans le fichier BODIES.DAT</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">imposeInitValue</span><span class="p">()</span>
 
          <span class="c1"># on exprime les shifts par rapport au repere principal d&#39;inertie</span>
          
          <span class="c1"># pour chaque contacteur</span>
          <span class="k">for</span> <span class="n">tact</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">contactors</span><span class="p">:</span>
             <span class="c1"># on passe le shift du repere global au repere d&#39;inertie</span>
             <span class="n">tact</span><span class="o">.</span><span class="n">shift</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">tact</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span>  
  
             <span class="c1"># mise a jour les donnees du contacteur, connaissant l&#39;orientation du repere principal d&#39;inertie</span>
             <span class="n">tact</span><span class="o">.</span><span class="n">updateFrame</span><span class="p">(</span><span class="n">P</span><span class="p">)</span></div>
  
    <span class="c1"># fonction qui verifie que tous les elements d&#39;un avatar sont associes</span>
    <span class="c1"># a un modele et un element</span>
<div class="viewcode-block" id="avatar.checkModelAndMaterialDefinitions"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.checkModelAndMaterialDefinitions">[docs]</a>    <span class="k">def</span> <span class="nf">checkModelAndMaterialDefinitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="sd">&quot;&quot;&quot;checkModelAndMaterialDefinitions(self):</span>

<span class="sd">       this functions checks if all volumic (or surfacic, in 2D) elements of the given avatar</span>
<span class="sd">       are associated to a model and a material. If any of the elements of tha given avatar is</span>
<span class="sd">       not associated to a model or a material it stops the exectution of the script.</span>
<span class="sd">       &quot;&quot;&quot;</span>
       <span class="c1"># on suppose initialement que tous les elements volumiques (ou surfaciques, en 2D) :</span>
       <span class="c1">#    * portent un modele</span>
       <span class="n">all_bulks_have_a_model</span><span class="o">=</span><span class="kc">True</span>
       <span class="c1">#    * portent un materiau</span>
       <span class="n">all_bulks_have_a_material</span><span class="o">=</span><span class="kc">False</span>

       <span class="c1"># pour chaque element de l&#39;avatar</span>
       <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
          <span class="c1"># si l&#39;element est suppose porter un modele et un materiau</span>
          <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">]:</span>
             <span class="c1"># si l&#39;element ne porte pas de modele</span>
             <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># on indique que tous les elements ne portent pas un modele</span>
                <span class="n">all_bulks_have_a_model</span><span class="o">=</span><span class="kc">False</span>
                <span class="c1"># on sort de la boucle</span>
                <span class="k">break</span>
             <span class="c1"># si l&#39;element ne porte pas de materiau</span>
             <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">material</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># on indique que tous les elements ne portent pas un materiau</span>
                <span class="n">all_bulks_have_a_material</span><span class="o">=</span><span class="kc">False</span>
                <span class="c1"># on sort de la boucle</span>
                <span class="k">break</span>

       <span class="c1"># si tous les elements ne portent pas de modele</span>
       <span class="k">if</span> <span class="ow">not</span> <span class="n">all_bulks_have_a_model</span><span class="p">:</span>
          <span class="c1"># on parcours les groupes de l&#39;avatar</span>
          <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
             <span class="c1"># si l&#39;avatar est maille, on laisse tomber le groupe &quot;all&quot;</span>
             <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">==</span> <span class="s2">&quot;MAILx&quot;</span> <span class="ow">and</span> <span class="n">group</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
             <span class="c1"># on parcours les elements du groupe courant</span>
             <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
                <span class="c1"># si l&#39;element est suppose porter un modele et n&#39;en porte pas</span>
                <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ele</span><span class="o">.</span><span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                   <span class="c1"># on a trouve un groupe qui ne porte de modele</span>
                   <span class="c1"># et on construit un message d&#39;erreur pour prvenir l&#39;utilisateur</span>
                   <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;bulks belonging to group </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">group</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2"> are not associated to any model!&quot;</span><span class="p">)</span>

       <span class="c1"># si tous les elements ne portent pas de materiau</span>
       <span class="k">if</span> <span class="ow">not</span> <span class="n">all_bulks_have_a_material</span><span class="p">:</span>
          <span class="c1"># on parcours les groupes de l&#39;avatar</span>
          <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
             <span class="c1"># si l&#39;avatar est maille, on laisse tomber le groupe &quot;all&quot;</span>
             <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">==</span> <span class="s2">&quot;MAILx&quot;</span> <span class="ow">and</span> <span class="n">group</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
             <span class="c1"># on parcours les elements du groupe courant</span>
             <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
                <span class="c1"># si l&#39;element est suppose porter un materiau et n&#39;en porte pas</span>
                <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ele</span><span class="o">.</span><span class="n">material</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                   <span class="c1"># on a trouve un groupe qui ne porte de materiau</span>
                   <span class="c1"># et on construit un message d&#39;erreur pour prvenir l&#39;utilisateur</span>
                   <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;bulks belonging to group </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">group</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2"> are not associated to any material!&quot;</span><span class="p">)</span></div>

<span class="c1"># ca doit appeler une routine dans nodes</span>
    <span class="c1">## translate an avatar</span>
    <span class="c1">#  @param dx,dy, dz tranlation vector</span>
<div class="viewcode-block" id="avatar.translate"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dx</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">dy</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">dz</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; usage self.tranlsate(dx=0.,dy=0.,dz=0.)</span>

<span class="sd">        where dx,dy, dz are components of translation vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">no</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
             <span class="n">no</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="o">=</span><span class="n">dy</span><span class="p">,</span><span class="n">dz</span><span class="o">=</span><span class="n">dz</span><span class="p">)</span></div>

    <span class="c1">## scale an avatar</span>
    <span class="c1">#  @param scale</span>
<div class="viewcode-block" id="avatar.scale"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; usage self.scale(scale = 1.0)</span>

<span class="sd">        where scale is the scale</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">no</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
             <span class="n">no</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span></div>

<div class="viewcode-block" id="avatar.rotate"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Euler&#39;</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">psi</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot; rotate(self, description=&#39;Euler&#39;, phi=0., theta=0., psi=0., alpha=0., axis=[0., 0., 1.], center=[0., 0., 0.])</span>

<span class="sd">        this function rotates the considered avatar, according to the given rotation parameters and a</span>
<span class="sd">        rotation center. Supported rotation paramters are: Euler&#39;s angles or an axis and an angle</span>

<span class="sd">        parameters:</span>

<span class="sd">        - self: the avatar itself</span>
<span class="sd">        - description=&#39;Euler&#39;: defines the rotation parameters:</span>

<span class="sd">          - if description = &#39;Euler&#39;, the rotation uses Euler&#39;s angles, consequently only phi, theta, psi and</span>
<span class="sd">            center are considered</span>
<span class="sd">          - if description = &#39;axis&#39;, the rotation uses an axis and an angle, consequently only axis, alpha and</span>
<span class="sd">            center are considered</span>
<span class="sd">        - phi: first Euler&#39;s angle (rotation with respect to z-axis)</span>
<span class="sd">        - theta: second Euler&#39;s angle (rotation with respect to x-axis)</span>
<span class="sd">        - psi: third Euler&#39;s angle (rotation with respect to z-axis, the only one admissible in 2D)</span>
<span class="sd">        - axis: a 3D vector defining rotation axis (colinear to z-axis in 2D)</span>
<span class="sd">        - angle: rotation angle</span>
<span class="sd">        - center: rotation center</span>

<span class="sd">        N.B. all angles are in radians</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># selon la parametrisation utilisee</span>
        <span class="k">if</span> <span class="n">description</span> <span class="o">==</span> <span class="s1">&#39;Euler&#39;</span><span class="p">:</span> <span class="c1"># cas des angles d&#39;Euler</span>
           <span class="c1"># test de coherence</span>
           <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">phi</span> <span class="o">!=</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">theta</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">)):</span>
              <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;in 2D only psi should be defined (rotation around z axis)&#39;</span><span class="p">)</span>
   
           <span class="c1"># construction de la matrice de rotation</span>
           <span class="n">q1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="mf">0.</span><span class="p">],</span>
                             <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span>  <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="mf">0.</span><span class="p">],</span>
                             <span class="p">[</span><span class="mf">0.</span><span class="p">,</span>             <span class="mf">0.</span><span class="p">,</span>            <span class="mf">1.</span><span class="p">]],</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
           <span class="n">q2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span>               <span class="mf">0.</span><span class="p">],</span>
                             <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span>
                             <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span>  <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)]],</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
           <span class="n">q3</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">),</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">),</span> <span class="mf">0.</span><span class="p">],</span>
                             <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">),</span>  <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">),</span> <span class="mf">0.</span><span class="p">],</span>
                             <span class="p">[</span><span class="mf">0.</span><span class="p">,</span>             <span class="mf">0.</span><span class="p">,</span>            <span class="mf">1.</span><span class="p">]],</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
           <span class="n">q</span>  <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span><span class="n">q2</span><span class="p">),</span><span class="n">q3</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">description</span> <span class="o">==</span> <span class="s1">&#39;axis&#39;</span><span class="p">:</span> <span class="c1"># cas ou on donne un axe de rotation</span>
           <span class="c1"># tests de coherence :</span>
           <span class="c1">#    * taille du vecteur</span>
           <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
              <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;the given axis should be a 3D vector&#39;</span><span class="p">)</span>
           <span class="c1">#    * coherence dans le cas 2D</span>
           <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">)):</span>
              <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;in 2D axis must be colinear with e_z (rotation around z axis)&#39;</span><span class="p">)</span>

           <span class="c1"># calcul du vecteur directeur de l&#39;axe (i.e. l&#39;axe normalise)</span>
           <span class="n">n</span> <span class="o">=</span> <span class="n">axis</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

           <span class="c1"># construction de la matrice de rotation</span>

           <span class="c1"># construction de la matrice associe a l&#39;operateur u |--&gt; n ^ u, ou ^ est</span>
           <span class="c1"># le produit vectoriel</span>
           <span class="n">cross</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">0.</span><span class="p">,</span>   <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>  <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                <span class="p">[</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>  <span class="mf">0.</span><span class="p">,</span>   <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                <span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="mf">0.</span><span class="p">]],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
           <span class="c1"># construction effective de la matrice de rotation (formule d&#39;Olinde Rodrigues) :</span>
           <span class="c1"># Q = cos(alpha)*I + (1 - cos(alpha))*(n x n) + sin(alpha)*cross,</span>
           <span class="c1"># ou I est le tenseur identite et x le produit tensoriel </span>
           <span class="n">q</span>  <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> \
                <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> \
                <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">cross</span>

        <span class="c1"># cas general</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="c1"># affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;unknown kind of parameters!&#39;</span><span class="p">)</span>
           
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
           <span class="n">Centre</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span> <span class="p">]</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">Centre</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
           <span class="n">node</span><span class="o">.</span><span class="n">applyAffineMapToCoor</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">Centre</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
           <span class="c1"># cas particulier des rigides</span>
           <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bulk</span><span class="p">,</span> <span class="n">rigid2d</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bulk</span><span class="p">,</span> <span class="n">rigid3d</span><span class="p">):</span>
              <span class="c1"># on tourne le repere local</span>
              <span class="n">bulk</span><span class="o">.</span><span class="n">applyLinearMapToFrame</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
              <span class="c1"># on doit ecrire la condition initiale correspondante a la rotation</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">imposeInitValue</span><span class="p">()</span></div>

    <span class="c1"># fonction qui transforme l&#39;objet en son symetrique par rapport a un plan</span>
<div class="viewcode-block" id="avatar.mirror"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.mirror">[docs]</a>    <span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;mirror(slef, n, center, atol=1.e-8):</span>

<span class="sd">        this function changes an avatar to its symmetrical through the</span>
<span class="sd">        given plane</span>

<span class="sd">        parameters:</span>

<span class="sd">        - self the avatar itself</span>
<span class="sd">        - n: normal to the considered plane</span>
<span class="sd">        - center: a point beonging to the considered plane</span>

<span class="sd">        optional parameters:</span>

<span class="sd">        - atol: absolute tolerance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># on normalise le vecteur othogonal au plan</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="o">&lt;</span> <span class="n">atol</span><span class="p">:</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;mirror :: norm of n is too small! &quot;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="n">norm</span>
 
        <span class="c1"># calcul d&#39;une base du plan</span>
        
        <span class="c1">#    * calcul d&#39;un premier vecteur norme orthogonal a n</span>

        <span class="c1"># si le vecteur n est dans le plan (xOy)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">atol</span><span class="p">:</span>
           <span class="c1"># on construit la base comme dans le cas 2D</span>
           <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.</span><span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>

           <span class="n">norm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
           <span class="k">if</span> <span class="n">norm</span> <span class="o">&lt;</span> <span class="n">atol</span><span class="p">:</span>
              <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;mirror :: norm of t is too small! &quot;</span><span class="p">)</span>
           <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">/</span><span class="n">norm</span>
        <span class="c1"># sinon</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="c1"># on construit la base en utilisant une methode &quot;generale&quot;</span>
           <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>

           <span class="n">norm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
           <span class="k">if</span> <span class="n">norm</span> <span class="o">&lt;</span> <span class="n">atol</span><span class="p">:</span>
              <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;mirrorByPlane :: norm of t is too small! &quot;</span><span class="p">)</span>
           <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">/</span><span class="n">norm</span>
       
        <span class="c1">## methode utilisee dans LMGC90 (cf. mod_SPSPx)</span>
        <span class="c1">#t = numpy.array([-n[1]*n[2], -n[2]*n[0], 2.*n[0]*n[1]])</span>
        <span class="c1">#norm = numpy.linalg.norm(t)</span>
        <span class="c1">#if norm &lt; atol:</span>
        <span class="c1">#   showError(&quot;mirror :: norm of t is too small! &quot;)</span>

        <span class="c1">#    * calcul du troisieme vecteur de la base</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

        <span class="c1"># matrice de passage : (n, t, s) -&gt; (x, y, z)</span>
        <span class="c1">#am : piege a con : numpy.array([n, t, s]) donne P^T et pas P...</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                         <span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                         <span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]]],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>

        <span class="c1"># matrice representative de la symetrie dans la base (n, t, s)</span>
        <span class="n">M_prime</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                               <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                               <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>

        <span class="c1"># matrice representative de la symetrie dans la base (x, y, z)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M_prime</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

        <span class="c1"># calcul du &quot;centre&quot; du plan comme un vecteur 3D</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
           <span class="n">Centre</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span> <span class="p">],</span> <span class="s1">&#39;d&#39;</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">Centre</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>

        <span class="c1"># calcul du symetrique de chaque noeud par rapport au plan</span>
        <span class="k">for</span> <span class="n">nod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
           <span class="n">nod</span><span class="o">.</span><span class="n">applyAffineMapToCoor</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
           <span class="c1"># cas des rigides</span>
           <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bulk</span><span class="p">,</span> <span class="n">rigid2d</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bulk</span><span class="p">,</span> <span class="n">rigid3d</span><span class="p">):</span>
              <span class="c1"># on tourne le repere local</span>
              <span class="n">bulk</span><span class="o">.</span><span class="n">applyLinearMapToFrame</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
              <span class="c1"># # on doit ecrire la condition initiale correspondant a la symetrie</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">imposeInitValue</span><span class="p">()</span>
           <span class="c1"># cas des dformables</span>

           
           <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bulk</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
              <span class="c1"># on retourne les elements</span>
              <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
           <span class="c1"># cas par defaut</span>
           <span class="k">else</span><span class="p">:</span>
              <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;mirror :: unknown bulk type!&#39;</span><span class="p">)</span></div>


    <span class="c1"># fonction qui cherche un noeud dans l&#39;avatar, a partir de ces coordonnees</span>
<div class="viewcode-block" id="avatar.findNode"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.findNode">[docs]</a>    <span class="k">def</span> <span class="nf">findNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coor</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;findNode(self, n, atol=1.e-8):</span>

<span class="sd">        this function return the index of the node which coordinates are </span>
<span class="sd">        coor, subject to the absolute tolerance atol, if it exists; </span>
<span class="sd">        None otherwise</span>

<span class="sd">        parameters:</span>

<span class="sd">        - self: the avatar</span>
<span class="sd">        - coor: the given coordinates</span>
<span class="sd">        - atol: absolute tolerance</span>

<span class="sd">        returned value:</span>

<span class="sd">        - index of the node, if it exists; None otherwise&quot;&quot;&quot;</span>

        <span class="c1"># on cree un objet numpy a partir des coordonnees</span>
        <span class="n">coor_numpy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
    
        <span class="c1"># si le noeud n&#39;a pas le bon nombre de coordonnees</span>
        <span class="k">if</span> <span class="n">coor_numpy</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
           <span class="c1"># on ne le trouvera pas</span>
           <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># pour chaque noeud de l&#39;avatar</span>
        <span class="k">for</span> <span class="n">nod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
           <span class="c1"># si le neoud courant a les coorodnnees cherchees</span>
           <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">coor_numpy</span><span class="p">,</span> <span class="n">nod</span><span class="o">.</span><span class="n">coor</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">):</span>
              <span class="c1"># on renvoie son indice</span>
              <span class="k">return</span> <span class="n">nod</span><span class="o">.</span><span class="n">number</span>

        <span class="c1"># si on arrive ici, on n&#39;a pas trouve le noeud</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<span class="c1">#    ## add a group</span>
<span class="c1">#    # @arg Group a group</span>
<span class="c1">#    def addGroup(self,Group):</span>
<span class="c1">#        &quot;&quot;&quot; Usage : avatar.addGroup(Group)</span>
<span class="c1">#            where Group is a group</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        self.groups.addGroup(Group)</span>
       
<span class="c1">#    ## add Groups of an iterator</span>
<span class="c1">#    # @arg Groups group iterator</span>
<span class="c1">#    def addGroups(self,Groups):</span>
<span class="c1">#        &quot;&quot;&quot; Usage : avatar.addGroups(groups)</span>
<span class="c1">#            where groups is a group iterator</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        for Group in Groups:</span>
<span class="c1">#            self.groups.addGroup(Group)</span>
<span class="c1"># </span>
<span class="c1">#</span>
<span class="c1">#</span>
<div class="viewcode-block" id="avatar.defineGroups"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.defineGroups">[docs]</a>    <span class="k">def</span> <span class="nf">defineGroups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># A REVOIR L ENDROIT DE LA DEFINITION DES GROUPES</span>
        <span class="sd">&quot;&quot;&quot;defineGroups(self)</span>

<span class="sd">        define groups linked to each elements</span>
<span class="sd">        ! beware the method is not robuste for too many mesh elements&quot;&quot;&quot;</span>
        

        <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">addGroup</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">))</span>

        <span class="c1"># affectation du groupe all: valable pour les rigides, defo, etc</span>
        <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span><span class="n">bulk</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># test pour savoir si on est bien un MAILx</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">!=</span> <span class="s1">&#39;MAILx&#39;</span><span class="p">):</span>
          <span class="c1"># fd affichage casse burne &lt;- une variable de bavardage ? </span>
          <span class="c1">#  print &#39;Only the group all will be defined&#39;</span>
          <span class="k">return</span>

        <span class="n">listeGroupes</span>     <span class="o">=</span>  <span class="p">[]</span>
        <span class="n">listeTypeElement</span> <span class="o">=</span>  <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span>  <span class="ow">not</span> <span class="ow">in</span> <span class="n">listeTypeElement</span><span class="p">:</span>
              <span class="n">listeTypeElement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bulk</span><span class="o">.</span><span class="n">etype</span><span class="p">)</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">addGroup</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">bulk</span><span class="o">.</span><span class="n">etype</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">etype</span><span class="p">]</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span><span class="n">bulk</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">etype</span><span class="p">]</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    
            <span class="k">if</span> <span class="n">bulk</span><span class="o">.</span><span class="n">physicalEntity</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">listeGroupes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">addGroup</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">bulk</span><span class="o">.</span><span class="n">physicalEntity</span><span class="p">))</span>
                <span class="n">listeGroupes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bulk</span><span class="o">.</span><span class="n">physicalEntity</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">physicalEntity</span><span class="p">]</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span><span class="n">bulk</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">physicalEntity</span><span class="p">]</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">])</span></div>

    <span class="c1"># fonction qui inidque si un groupe appartient a un avatar ou non</span>
<div class="viewcode-block" id="avatar.hasGroup"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.hasGroup">[docs]</a>    <span class="k">def</span> <span class="nf">hasGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;hasGroup(self,group):</span>

<span class="sd">        this functions return &quot;True&quot; iff the given group belongs to the given avatar</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">group</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span></div>

    <span class="c1">## setting model</span>
<div class="viewcode-block" id="avatar.defineModel"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.defineModel">[docs]</a>    <span class="k">def</span> <span class="nf">defineModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">group</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span><span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;defineModel(self,group=&#39;all&#39;,model=None)</span>

<span class="sd">        match a model (class model) or a set of models (class model) to a group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># si le groupe demande n&#39;existe pas</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasGroup</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;group: &#39;</span> <span class="o">+</span> <span class="n">group</span> <span class="o">+</span> <span class="s1">&#39; do not belong to this avatar!&#39;</span><span class="p">)</span>

        <span class="c1"># verification de la validite du modele</span>
        
        <span class="c1"># si le modele n&#39;est pas une instance de la classe modele</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">class_model</span><span class="p">):</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;given model must be a model instance!&quot;</span><span class="p">)</span>

        <span class="c1"># si la dimension du modele differe de celle de l&#39;avatar</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="n">model</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">msg</span>  <span class="o">=</span> <span class="s2">&quot;model dimension differs from avatar dimension :</span><span class="se">\n</span><span class="s2">&quot;</span>
           <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;   avatar : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;D</span><span class="se">\n</span><span class="s2">&quot;</span>
           <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;   model  : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;D&quot;</span>
           <span class="n">showError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># si l&#39;element fini est incomptible avec l&#39;avatar</span>
        <span class="c1">#    * cas de l&#39;element fini classique avec un rigide</span>
        <span class="c1"># si on refile un modele base sur element fini classique a un avatar rigide</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">==</span> <span class="s1">&#39;RBDY2&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">==</span> <span class="s1">&#39;RBDY3&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">element</span> <span class="ow">in</span> <span class="n">rigidElements</span><span class="p">:</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;a standard finite element cannot be handled by a rigid avatar!&quot;</span><span class="p">)</span>
        <span class="c1"># si on refile un element fini rigide a un avatar deformable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">==</span> <span class="s1">&#39;MAILx&#39;</span> <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">element</span> <span class="ow">in</span> <span class="n">rigidElements</span><span class="p">:</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;a rigid finite element cannot be handled by a meshed avatar!&quot;</span><span class="p">)</span>

        <span class="c1"># si un modele a deja ete affecte a une partie des elements de l&#39;avatar</span>
        <span class="c1"># et que le modele qu&#39;on s&#39;apprete a affecter est d&#39;un type different</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">modelType</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">physics</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modelType</span><span class="p">:</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;Different types of models cannot be associated to the same avatar!&quot;</span><span class="p">)</span>

        <span class="c1"># on initialise le nombre de bulks auxquels on a associe le modele</span>
        <span class="c1"># donne</span>
        <span class="n">nb_model_defined_bulks</span><span class="o">=</span><span class="mi">0</span>
        <span class="c1"># pour chaque bulk, associe au groupe group </span>
        <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
           <span class="k">try</span><span class="p">:</span>
              <span class="c1"># on tente d&#39;associer le modele donne a l&#39;element courant</span>
              <span class="n">bulk</span><span class="o">.</span><span class="n">defineModel</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
              <span class="c1"># si on a pu associer le modele donne a l&#39;element courant</span>
              <span class="c1">#    * on incremente le nombre de bulks auxquels on a associe le</span>
              <span class="c1">#      modele donne</span>
              <span class="n">nb_model_defined_bulks</span> <span class="o">+=</span> <span class="mi">1</span>
              <span class="c1">#    * on definit les ddl pour tous les noeuds de l&#39;element</span>
              <span class="c1"># pour chaque noeud </span>
              <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                 <span class="c1"># on definit les ddl en fonction du modele </span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">defineDof</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
           <span class="c1"># si l&#39;association du modele a l&#39;element courant a leve une exception</span>
           <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
              <span class="c1"># si ce n&#39;est pas l&#39;exception attendue, i.e. celle prevue dans</span>
              <span class="c1"># la methode defineModel de la classe bulk, on la renvoie</span>
              <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;Cannot add model&quot;</span><span class="p">):</span>
                 <span class="k">raise</span>

        <span class="c1"># si le modele donne n&#39;a pu etre associe a aucun element de l&#39;avatar</span>
        <span class="k">if</span> <span class="n">nb_model_defined_bulks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">msg</span>  <span class="o">=</span> <span class="s2">&quot;model with element &quot;</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">element</span>
           <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; can not be associated to the group &quot;</span> <span class="o">+</span> <span class="n">group</span> <span class="o">+</span> <span class="s2">&quot; of the considered avatar&quot;</span>
           <span class="n">showError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># on garde le type de model associe a l&#39;avatar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modelType</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">physics</span></div>
 
    <span class="c1">## set the material of an element</span>
    <span class="c1">#</span>
<div class="viewcode-block" id="avatar.defineMaterial"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.defineMaterial">[docs]</a>    <span class="k">def</span> <span class="nf">defineMaterial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">group</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span><span class="n">material</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; defineMaterial(self,group=&#39;all&#39;,material=None)</span>

<span class="sd">        associate a material or a material container to the element</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># si le groupe demande n&#39;existe pas</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasGroup</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;group: &#39;</span> <span class="o">+</span> <span class="n">group</span> <span class="o">+</span> <span class="s1">&#39; do not belong to this avatar!&#39;</span><span class="p">)</span>

        <span class="c1"># verification de la validite du materiau</span>
        
        <span class="c1"># si le materiau n&#39;est pas une instance de la classe materiau</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">material</span><span class="p">,</span> <span class="n">class_material</span><span class="p">):</span>
           <span class="c1"># si le materiau est une chaine</span>
           <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">material</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
              <span class="c1"># on affiche un message d&#39;erreur pour les vieux</span>
              <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;Sorry, using strings as materials is no longer supported!</span><span class="se">\n</span><span class="s2">You must use an object </span><span class="se">\&quot;</span><span class="s2">material</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span> 
           <span class="c1"># sinon,</span>
           <span class="k">else</span><span class="p">:</span>
              <span class="c1"># on affiche un message plus brutal</span>
              <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;material must be a material instance!&quot;</span><span class="p">)</span>

        <span class="c1"># ici, on est sur que le materiau est un objet de type material</span>

        <span class="c1"># si le materiau est defini en externe (i.e. un USER_MAT)</span>
        <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">materialType</span> <span class="o">==</span> <span class="s1">&#39;USER_MAT&#39;</span><span class="p">:</span>
           <span class="c1"># on affiche un message inidquant que les tests de coherence materiau/modele sont desactives</span>
           <span class="n">showWarning</span><span class="p">(</span><span class="s2">&quot;Consistancy tests will not be performed since the given material is user defined!&quot;</span><span class="p">)</span>

        <span class="c1"># on initialise le nombre de bulks auxquels on a associe le modele</span>
        <span class="c1"># donne</span>
        <span class="n">nb_material_defined_bulks</span><span class="o">=</span><span class="mi">0</span>
        <span class="c1"># pour chaque bulk, associe au groupe group </span>
        <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
           <span class="k">try</span><span class="p">:</span>
              <span class="c1"># on tente d&#39;associer le materiau donne a l&#39;element courant</span>
              <span class="n">bulk</span><span class="o">.</span><span class="n">defineMaterial</span><span class="p">(</span><span class="n">material</span><span class="p">)</span>
              <span class="c1"># si on a pu associer le modele donne a l&#39;element courant,</span>
              <span class="c1"># on incremente le nombre de bulks auxquels on a associe le</span>
              <span class="c1"># modele donne</span>
              <span class="n">nb_material_defined_bulks</span> <span class="o">+=</span> <span class="mi">1</span>
           <span class="c1"># si l&#39;association du materiau a l&#39;element courant a leve une </span>
           <span class="c1"># exception</span>
           <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
              <span class="c1"># si ce n&#39;est pas l&#39;exception attendue, i.e. celle prevue dans</span>
              <span class="c1"># la methode defineMaterial de la classe bulk, on la renvoie</span>
              <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;Cannot add material&quot;</span><span class="p">):</span>
                 <span class="k">raise</span>

        <span class="c1"># si le materiau donne n&#39;a pu etre associe a aucun element de l&#39;avatar</span>
        <span class="k">if</span> <span class="n">nb_material_defined_bulks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">msg</span>  <span class="o">=</span> <span class="s2">&quot;material &quot;</span> <span class="o">+</span> <span class="n">material</span><span class="o">.</span><span class="n">nom</span> <span class="o">+</span> <span class="s2">&quot; cannot be associated &quot;</span>
           <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;to the group &quot;</span> <span class="o">+</span> <span class="n">group</span> <span class="o">+</span> <span class="s2">&quot; since no bulk of this group is &quot;</span>
           <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;associated to a model&quot;</span>
           <span class="n">showError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>

    <span class="c1">## build a string to represent the avatar            </span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">impr</span> <span class="o">=</span><span class="s1">&#39;avatar number : </span><span class="si">%10s</span><span class="s1"> of type </span><span class="si">%5s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">impr</span>

    <span class="c1">## add contactors</span>
    <span class="c1"># @arg Tact a contactor</span>
<div class="viewcode-block" id="avatar.addContactors"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.addContactors">[docs]</a>    <span class="k">def</span> <span class="nf">addContactors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">shape</span><span class="p">,</span><span class="n">color</span><span class="p">,</span><span class="n">group</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;addContactors(self,shape,color,group=&#39;all&#39;,**options)</span>

<span class="sd">        define contactors for the elements of a group</span>

<span class="sd">        parameters:</span>

<span class="sd">        - self: the contactor itself</span>
<span class="sd">        - shape: type of the contactors</span>
<span class="sd">        - color: color of the contactor</span>

<span class="sd">        optional parameters:</span>

<span class="sd">        - group=&#39;all&#39;: name of the considered group</span>
<span class="sd">        - ** options&#39;: a set of options associated to the contactors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># si le groupe demande n&#39;existe pas</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasGroup</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;group: &#39;</span> <span class="o">+</span> <span class="n">group</span> <span class="o">+</span> <span class="s1">&#39; do not belong to this avatar!&#39;</span><span class="p">)</span>

        <span class="c1"># si la dimension du contacteur differe de celle de l&#39;avatar</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">dimension2contactor</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">]:</span>
           <span class="c1"># on construit un message d&#39;erreur rappelant les types disponibles</span>
           <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Contactor type not available in &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;D</span><span class="se">\n</span><span class="s2"> the available contactors in &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;D are:</span><span class="se">\n</span><span class="s2">&quot;</span>
           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dimension2contactor</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">]:</span>
               <span class="n">msg</span><span class="o">+=</span><span class="n">i</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
           <span class="c1"># on l&#39;affiche</span>
           <span class="n">showError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># si le type de contacteur est incomptible avec l&#39;avatar</span>
        <span class="c1">#    * cas du contacteur element fini avec un rigide</span>
        <span class="c1"># si on refile un contacteur base sur element fini a un avatar rigide</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">==</span> <span class="s1">&#39;RBDY2&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">==</span> <span class="s1">&#39;RBDY3&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">rigidContactor</span><span class="p">:</span>
           <span class="c1"># on construit un message d&#39;erreur rappelant les types disponibles</span>
           <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Contactor type not available for a rigid avatar</span><span class="se">\n</span><span class="s2"> the available contactors for a rigid avatar are:</span><span class="se">\n</span><span class="s2">&quot;</span>
           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rigidContactor</span><span class="p">:</span>
               <span class="n">msg</span><span class="o">+=</span><span class="n">i</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
           <span class="c1"># on l&#39;affiche</span>
           <span class="n">showError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1">#    * cas du contaceur rigide (autre que le POLYD) avec un maillage element fini</span>
        <span class="c1"># si on refile un contacteur rigide a un avatar deformable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atype</span> <span class="o">==</span> <span class="s1">&#39;MAILx&#39;</span> <span class="ow">and</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">rigidContactor</span><span class="p">:</span>
           <span class="c1"># on construit un message d&#39;erreur rappelant les types disponibles</span>
           <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Contactor type not available for a meshed avatar</span><span class="se">\n</span><span class="s2"> the available contactors for a meshed avatar are:</span><span class="se">\n</span><span class="s2">&quot;</span>
           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">listeContactor</span><span class="p">:</span>
              <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rigidContactor</span><span class="p">:</span>
                 <span class="n">msg</span><span class="o">+=</span><span class="n">i</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
           <span class="c1"># on l&#39;affiche</span>
           <span class="n">showError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># on recupere les clefs du dictionnaires donnant les options du contacteur</span>
        <span class="n">cles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># si le contacteur est une ligne ou une surface candidate</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="o">==</span> <span class="s1">&#39;CLxxx&#39;</span> <span class="ow">or</span> <span class="n">shape</span> <span class="o">==</span> <span class="s1">&#39;CSxx3&#39;</span> <span class="ow">or</span> <span class="n">shape</span> <span class="o">==</span> <span class="s1">&#39;CSxx4&#39;</span><span class="p">:</span>
           <span class="c1"># si on ne donne pas de poids pour placer le contacteur</span>
           <span class="k">if</span> <span class="s1">&#39;weights&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cles</span><span class="p">:</span>
              <span class="c1"># on affecte la valeur None a l&#39;option weights, pour activer le positionnement automatique des candidats aux noeuds</span>
              <span class="n">options</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
 
        <span class="c1"># on initialise une liste vide</span>
        <span class="n">list_ele</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># pour chaque element du groupe</span>
        <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span> 
           <span class="c1"># on ajoute l&#39;element a la liste</span>
           <span class="n">list_ele</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span>

        <span class="c1"># on construit un seul nouveau contacteur avec tous les elements du groupe</span>
        <span class="c1"># N.B.: la copie profonde de la liste d&#39;elements est effectuee par chaque constructeur de contacteur maille,</span>
        <span class="c1">#       il est donc inutile de le faire ici</span>
        <span class="n">contact</span><span class="o">=</span><span class="n">contactorFactory</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="n">list_ele</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">contact</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
          <span class="k">for</span> <span class="n">c_</span> <span class="ow">in</span> <span class="n">contact</span> <span class="p">:</span>  
            <span class="c1"># une fois le contacteur entierement defini, on l&#39;ajoute au container de contacteurs de l&#39;avatar</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addContactor</span><span class="p">(</span><span class="n">c_</span><span class="p">)</span>
            <span class="c1"># et au container de contacteurs portes par le groupe</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">addContactor</span><span class="p">(</span><span class="n">c_</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>    
          <span class="c1"># une fois le contacteur entierement defini, on l&#39;ajoute au container de contacteurs de l&#39;avatar</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_addContactor</span><span class="p">(</span><span class="n">contact</span><span class="p">)</span>
          <span class="c1"># et au container de contacteurs portes par le groupe</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">addContactor</span><span class="p">(</span><span class="n">contact</span><span class="p">)</span></div>

<div class="viewcode-block" id="avatar.imposeDrivenDof"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.imposeDrivenDof">[docs]</a>    <span class="k">def</span> <span class="nf">imposeDrivenDof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">group</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span><span class="n">component</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s1">&#39;predefined&#39;</span><span class="p">,</span><span class="n">ct</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">amp</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">omega</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                        <span class="n">phi</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">rampi</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span><span class="n">ramp</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">evolutionFile</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dofty</span><span class="o">=</span><span class="s1">&#39;temp&#39;</span><span class="p">,</span> <span class="n">plot_time_range</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function associate a boundary condition to each node of the considered group of the</span>
<span class="sd">        considered avatar</span>

<span class="sd">        parameters:</span>

<span class="sd">        - dofty : type of boundary condition (vlocy for velocity, force for.. force, temp for temperature and flux for heat flux)</span>
<span class="sd">        - description : &#39;predefined&#39; or &#39;evolution&#39;</span>
<span class="sd">        - plot_time_range: if provided, must have two values to display the boundary condition</span>

<span class="sd">          * &#39;predefined&#39;: ct, amp, omega, phi, rampi and ramp must be defined</span>
<span class="sd">            so that the boundary value will be : [ ct + amp * cos(omega*t+phi) ] * min(1, rampi+ramp*t),</span>
<span class="sd">            where t is the time</span>
<span class="sd">          * &#39;evolution&#39; : evolutionFile must be defined</span>
<span class="sd">            the input file must contain two columns separated by a blank character. First columns is time</span>
<span class="sd">            and the second one the imposed value. A linear interpolation is made by LMGC90 to compute values</span>
<span class="sd">            at computational times different from those given in input </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># some sanity/paranoid checks</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasGroup</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
           <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;group: &#39;</span> <span class="o">+</span> <span class="n">group</span> <span class="o">+</span> <span class="s1">&#39; do not belong to this avatar!&#39;</span><span class="p">)</span>

        <span class="c1"># on verifie la liste des composantes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
           <span class="n">component</span> <span class="o">=</span> <span class="p">[</span><span class="n">component</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">modelType</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;You must define the model of the considered avatar before impose driven dof!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;The given list of components is empty!&quot;</span><span class="p">)</span>
 
        <span class="c1"># on pour chaque composante</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">component</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
               <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;a component must be an integer!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;a component must be larger or equal to 1!&quot;</span><span class="p">)</span>


        <span class="c1"># on verifie le type de ddl impose</span>

        <span class="c1"># si on ne reconnait pas le type de ddl impose</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dofty</span> <span class="ow">in</span> <span class="n">model2dofty</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">modelType</span><span class="p">]:</span>
           <span class="c1"># on construit un message d&#39;erreur rappelant les types disponibles</span>
           <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Unknown degree of freedom type</span><span class="se">\n</span><span class="s1"> must be among:</span><span class="se">\n</span><span class="s1">&#39;</span>
           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">model2dofty</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">modelType</span><span class="p">]:</span>
              <span class="n">msg</span><span class="o">+=</span><span class="n">i</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
           <span class="c1"># on l&#39;affiche</span>
           <span class="n">showError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_time_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">plt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
          <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">plot_time_range</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;plot_time_range must have two values for the display range&#39;</span>
          <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">plot_time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plot_time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">description</span> <span class="o">==</span> <span class="s1">&#39;predefined&#39;</span><span class="p">:</span>
            <span class="n">cl</span> <span class="o">=</span> <span class="p">(</span> <span class="n">ct</span> <span class="o">+</span> <span class="n">amp</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span> <span class="n">omega</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">phi</span> <span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">rampi</span><span class="o">+</span><span class="n">t</span><span class="o">*</span><span class="n">ramp</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">cl</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ugly attempt to find the evolution file</span>
            <span class="n">ef</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">evolutionFile</span><span class="p">)</span>
            <span class="n">ef</span> <span class="o">=</span> <span class="n">ef</span> <span class="k">if</span> <span class="n">ef</span><span class="o">.</span><span class="n">is_file</span><span class="p">()</span> <span class="k">else</span> <span class="s1">&#39;DATBOX&#39;</span><span class="o">/</span><span class="n">ef</span>
            <span class="k">if</span> <span class="n">ef</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
              <span class="n">cl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">ef</span><span class="p">)</span>
              <span class="n">cl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">cl</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">cl</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
              <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">cl</span><span class="p">)</span>
              <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">drvDof</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">no</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">no</span><span class="o">.</span><span class="n">dof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
               <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;no dof defined. It&#39;s defined when you define a model.&quot;</span><span class="p">)</span>
   
            <span class="n">no</span><span class="o">.</span><span class="n">imposeDrivenDof</span><span class="p">(</span><span class="n">component</span><span class="p">,</span><span class="n">description</span><span class="p">,</span> <span class="n">ct</span><span class="p">,</span><span class="n">amp</span><span class="p">,</span><span class="n">omega</span><span class="p">,</span><span class="n">phi</span><span class="p">,</span><span class="n">rampi</span><span class="p">,</span>
                               <span class="n">ramp</span><span class="p">,</span><span class="n">evolutionFile</span><span class="p">,</span><span class="n">dofty</span><span class="p">)</span></div>

<div class="viewcode-block" id="avatar.relaxDrivenDof"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.relaxDrivenDof">[docs]</a>    <span class="k">def</span> <span class="nf">relaxDrivenDof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;relaxDrivenDof(self, group=&#39;all&#39;, component=1):</span>

<span class="sd">        this function relax driven dof</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># si le groupe demande n&#39;existe pas</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasGroup</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;group: &#39;</span> <span class="o">+</span> <span class="n">group</span> <span class="o">+</span> <span class="s1">&#39; does not belong to this avatar!&#39;</span><span class="p">)</span>

        <span class="c1"># on verifie la liste des composantes</span>

        <span class="c1"># si la liste des composantes n&#39;est pas une liste</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
           <span class="c1"># on la transforme en liste</span>
           <span class="n">component</span> <span class="o">=</span> <span class="p">[</span><span class="n">component</span><span class="p">]</span>

        <span class="c1"># si l&#39;avatar ne connait pas son type de modele</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">modelType</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;You must define the model of the considered avatar before impose driven dof!&quot;</span><span class="p">)</span>

        <span class="c1"># si la liste des composantes est vide</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;The given list of components is empty!&quot;</span><span class="p">)</span>
 
        <span class="c1"># on pour chaque composante</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">component</span><span class="p">:</span>
            <span class="c1"># si la composante courante n&#39;est pas un entier</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
               <span class="c1"># on affiche un message d&#39;erreur</span>
               <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;a component must be an integer!&quot;</span><span class="p">)</span>

        <span class="c1"># si la plus petite composante consideree est plus petite que 1</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;a component must be larger or equal to 1!&quot;</span><span class="p">)</span>

        <span class="c1"># ici, on est sur que la liste des composantes est bonne</span>

        <span class="c1"># pour chaque noeud du groupe</span>
        <span class="k">for</span> <span class="n">no</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
           <span class="c1"># si le noeud courant ne porte pas d&#39;objet dof</span>
           <span class="k">if</span> <span class="n">no</span><span class="o">.</span><span class="n">dof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
              <span class="c1"># on affiche un message d&#39;erreur</span>
              <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;no dof defined. It&#39;s defined when you define a model.&quot;</span><span class="p">)</span>
   
           <span class="c1"># on relaxe la condition limite porte par le ddl du noeud, suivant la composante donnee</span>
           <span class="n">no</span><span class="o">.</span><span class="n">relaxDrivenDof</span><span class="p">(</span><span class="n">component</span><span class="p">)</span></div>

<div class="viewcode-block" id="avatar.imposeInitValue"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.imposeInitValue">[docs]</a>    <span class="k">def</span> <span class="nf">imposeInitValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">group</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span><span class="n">component</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">value</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;imposeInitValue(self,group=&#39;all&#39;,component=1,value=0.)</span>

<span class="sd">        impose a value to a degree of freedom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># si le groupe demande n&#39;existe pas</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasGroup</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;group: &#39;</span> <span class="o">+</span> <span class="n">group</span> <span class="o">+</span> <span class="s1">&#39; does not belong to this avatar!&#39;</span><span class="p">)</span>

        <span class="c1"># si la liste des composantes n&#39;est pas une liste</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
           <span class="c1"># on la transforme en liste</span>
           <span class="n">component</span> <span class="o">=</span> <span class="p">[</span><span class="n">component</span><span class="p">]</span>
        <span class="c1"># si la liste des valeurs n&#39;est pas une liste </span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
           <span class="c1"># on la transforme en liste</span>
           <span class="n">value</span>     <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>

        <span class="c1"># si la liste des composantes n&#39;est pas de la meme taille que</span>
        <span class="c1"># la liste des valeurs</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;You must define a value for each component!&quot;</span><span class="p">)</span>

        <span class="c1"># si la liste des composantes est vide</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;The given list of components is empty!&quot;</span><span class="p">)</span>
 
        <span class="c1"># on enumere la liste des composantes</span>
        <span class="k">for</span> <span class="n">indic</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">component</span><span class="p">):</span>
            <span class="c1"># si la composante courante n&#39;est pas un entier</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
               <span class="c1"># on affiche un message d&#39;erreur</span>
               <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;a component must be an integer!&quot;</span><span class="p">)</span>
            <span class="c1"># on tente de convertir la valeur associee a la composante courante en reel</span>
            <span class="k">try</span><span class="p">:</span>
               <span class="n">value</span><span class="p">[</span><span class="n">indic</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">indic</span><span class="p">])</span>
            <span class="c1"># si on echoue</span>
            <span class="k">except</span><span class="p">:</span>
               <span class="c1"># on affiche un message d&#39;erreur</span>
               <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;a value must be a float!&quot;</span><span class="p">)</span>

        <span class="c1"># si la plus petite composante consideree est plus petite que 1</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;a component must be larger or equal to 1!&quot;</span><span class="p">)</span>

        <span class="c1">## ici, on est sur que tout est bon</span>
 
        <span class="c1"># on indique que l&#39;avatar porte une condition initiale sur certains noeuds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iniDof</span> <span class="o">=</span> <span class="kc">True</span>
            
        <span class="k">for</span> <span class="n">no</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">no</span><span class="o">.</span><span class="n">dof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
               <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;no dof defined. It&#39;s defined when you define a model.&quot;</span><span class="p">)</span>
   
            <span class="n">no</span><span class="o">.</span><span class="n">imposeInitValue</span><span class="p">(</span><span class="n">component</span><span class="p">,</span><span class="n">value</span><span class="p">)</span></div>
 
    <span class="c1"># fonction qui construit un nouveau groupe comme le sous-groupe</span>
    <span class="c1"># d&#39;un groupe existant</span>
<div class="viewcode-block" id="avatar.addGroupUsingPredicate"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.addGroupUsingPredicate">[docs]</a>    <span class="k">def</span> <span class="nf">addGroupUsingPredicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">super_group</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
       <span class="sd">&quot;&quot;&quot;adddGroupUsingPredicate(self, name, predicate, super_group=&#39;all&#39;):</span>

<span class="sd">       this function builds and add a new group to the avatar, by</span>
<span class="sd">       selecting nodes verifying a given predicate. All nodes</span>
<span class="sd">       verifying the predicate are added to the new group.</span>
<span class="sd">       If all nodes supporting an element are in the new group, this</span>
<span class="sd">       element is also added to the new group.</span>

<span class="sd">       parameters:</span>

<span class="sd">       - self : the avatar itself</span>
<span class="sd">       - name : the name of the new group</span>
<span class="sd">       - predicate : the given predicate defined as a function</span>
<span class="sd">         of the coordinates returning a boolean</span>

<span class="sd">       optional parameters:</span>

<span class="sd">       - super_group=&#39;all&#39; : the new group is defines as a subgroup of this group</span>
<span class="sd">       &quot;&quot;&quot;</span>
       <span class="c1"># on verifie que le nom du nouveau groupe soit une chaine de caracteres</span>
       
       <span class="c1"># si le nom du nouveau groupe n&#39;est pas une chaine de caracteres</span>
       <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
          <span class="c1"># on affiche un message d&#39;erreur</span>
          <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;A group name must be a string!&quot;</span><span class="p">)</span>

       <span class="c1"># si le groupe demande n&#39;existe pas</span>
       <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasGroup</span><span class="p">(</span><span class="n">super_group</span><span class="p">):</span>
          <span class="c1"># on affiche un warning</span>
          <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;group: &#39;</span> <span class="o">+</span> <span class="n">super_group</span> <span class="o">+</span> <span class="s1">&#39; does not belong to this avatar!</span><span class="se">\n</span><span class="s1">The new group &#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; cannot be built!&#39;</span><span class="p">)</span>

       <span class="c1"># ici, on est sur que le nom du groupe est correct</span>
 
       <span class="c1"># on cree le nouveau groupe</span>
       <span class="n">sub_group</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

       <span class="c1"># tri des noeuds</span>
       
       <span class="c1"># on definit la liste des indices des noeuds appartenant au nouveau groupe a vide</span>
       <span class="n">new_numbers</span><span class="o">=</span><span class="p">[]</span>
       <span class="c1"># pour chaque neoud du groupe existant</span>
       <span class="k">for</span> <span class="n">nod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">super_group</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
          <span class="c1"># on essaye de tester les coordonnees du noeud courant</span>
          <span class="k">try</span><span class="p">:</span>
             <span class="c1"># on teste si les coordonnees du noeud courant verifient</span>
             <span class="c1"># le predicat</span>
             <span class="n">is_verfied</span> <span class="o">=</span> <span class="n">predicate</span><span class="p">(</span><span class="n">nod</span><span class="o">.</span><span class="n">coor</span><span class="p">)</span>
          <span class="c1"># si on echoue</span>
          <span class="k">except</span><span class="p">:</span>
             <span class="c1"># on affiche un message d&#39;erreur</span>
             <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;Applying the given predicate on the nodes of this avatar raised an exception!</span><span class="se">\n</span><span class="s2">Please check your predicate (pay attention to the dimension)&quot;</span><span class="p">)</span>
             <span class="c1">## on quitte le programme</span>
             <span class="c1">#sys.exit(0)</span>

          <span class="c1"># ici, on est sur que le predicat a pu etre applique et on peu analyser le resultat</span>
          
          <span class="c1"># si les coordonnees du noeud verifient le predicat</span>
          <span class="k">if</span> <span class="n">is_verfied</span><span class="p">:</span>
             <span class="c1"># on ajoute le noeud au groupe</span>
             <span class="n">sub_group</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">nod</span><span class="p">)</span>
             <span class="c1"># on ajoute le numero du noeud a la liste des numeros de noeuds du nouveau groupe</span>
             <span class="n">new_numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nod</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>

       <span class="c1"># si l&#39;ensemble des noeuds du nouveau sous-groupe est vide</span>
       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_group</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="c1"># on affiche un warning</span>
          <span class="n">showWarning</span><span class="p">(</span><span class="s2">&quot;The new group &quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; is empty!&quot;</span><span class="p">)</span>
       <span class="c1"># sinon,</span>
       <span class="k">else</span><span class="p">:</span>
          <span class="c1"># tri des elements</span>

          <span class="c1"># pour chaque element du groupe existant</span>
          <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">super_group</span><span class="p">]</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
             <span class="c1"># on supppose initialement que l&#39;element fait partie du nouveau groupe</span>
             <span class="c1"># i.e. s&#39;appuie sur un ensemble de noeud inclus dans l&#39;ensemble de noeuds du nouveau groupe</span>
             <span class="n">in_new</span><span class="o">=</span><span class="kc">True</span>
             <span class="c1"># pour chaque noeud de la connectivite de l&#39;element</span>
             <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                <span class="c1"># si le noeud courant ne fait pas partie du nouveau groupe</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">new_numbers</span><span class="p">:</span>
                   <span class="c1"># on indique que l&#39;element ne saurait faire partie du nouveau groupe</span>
                   <span class="n">in_new</span><span class="o">=</span><span class="kc">False</span>
                   <span class="c1"># on sort de la boucle</span>
                   <span class="k">break</span>

             <span class="c1"># si l&#39;element fait partie du nouveau groupe</span>
             <span class="k">if</span> <span class="n">in_new</span><span class="p">:</span>
                <span class="c1"># on l&#39;ajoute au nouveau groupe</span>
                <span class="n">sub_group</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span>

          <span class="c1"># si l&#39;ensemble des elements du nouveau sous-groupe est vide</span>
          <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_group</span><span class="o">.</span><span class="n">bulks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
             <span class="c1"># on affiche un warning</span>
             <span class="n">showWarning</span><span class="p">(</span><span class="s2">&quot;The new group &quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; contains no element!&quot;</span><span class="p">)</span>

          <span class="c1"># on ajoute le groupe a l&#39;avatar &lt;- si il n est pas vide !!</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">addGroup</span><span class="p">(</span><span class="n">sub_group</span><span class="p">)</span></div>
          
    <span class="c1"># fonction qui renvoie la liste des noeuds d&#39;un groupe physique</span>
    <span class="c1"># existant</span>
<div class="viewcode-block" id="avatar.getNodebyGroup"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.getNodebyGroup">[docs]</a>    <span class="k">def</span> <span class="nf">getNodebyGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
       <span class="sd">&quot;&quot;&quot;getNodebyGroup(self,group):</span>
<span class="sd">       this functions return the node list by physical group to this avatar</span>
<span class="sd">       &quot;&quot;&quot;</span>
       <span class="c1"># on teste si le groupe physique existe pour cet avatar</span>
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasGroup</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
          <span class="n">listnode</span> <span class="o">=</span> <span class="p">[]</span>
          <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
             <span class="n">listnode</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
       <span class="k">else</span> <span class="p">:</span>
          <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;group: &#39;</span> <span class="o">+</span> <span class="n">group</span> <span class="o">+</span> <span class="s1">&#39; do not belong to this avatar!&#39;</span><span class="p">)</span>
          
       <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listnode</span><span class="p">)</span></div>

<div class="viewcode-block" id="avatar.getNodeCoor"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.getNodeCoor">[docs]</a>    <span class="k">def</span> <span class="nf">getNodeCoor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">noid</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
       <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">       Get the real coordinates of a node</span>
<span class="sd">       &quot;&quot;&quot;</span>
       <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">noid</span><span class="p">]</span><span class="o">.</span><span class="n">coor</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">noid</span><span class="p">]</span><span class="o">.</span><span class="n">dof</span><span class="o">.</span><span class="n">disp</span></div>

<div class="viewcode-block" id="avatar.getBulkFrame"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.getBulkFrame">[docs]</a>    <span class="k">def</span> <span class="nf">getBulkFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">elid</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the real orientation of an element</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ele</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">elid</span><span class="p">]</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">ele</span><span class="o">.</span><span class="n">axis</span>
        <span class="n">node</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">dof</span><span class="o">.</span><span class="n">rot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span> <span class="n">node</span><span class="o">.</span><span class="n">dof</span><span class="o">.</span><span class="n">rot</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">frame</span></div>

<div class="viewcode-block" id="avatar.updateReferenceConfig"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.avatar.updateReferenceConfig">[docs]</a>    <span class="k">def</span> <span class="nf">updateReferenceConfig</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use current configuration as a reference configuration</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># managing translation</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">coor</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="n">dof</span><span class="o">.</span><span class="n">disp</span>
            <span class="n">node</span><span class="o">.</span><span class="n">dof</span><span class="o">.</span><span class="n">disp</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># managing rotation... rigid3d only</span>
        <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
          <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ele</span><span class="p">,</span> <span class="n">rigid3d</span><span class="p">):</span>
            <span class="n">node</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">dof</span><span class="o">.</span><span class="n">rot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
              <span class="n">frame</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span> <span class="n">node</span><span class="o">.</span><span class="n">dof</span><span class="o">.</span><span class="n">rot</span><span class="p">,</span> <span class="n">ele</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
              <span class="n">ele</span><span class="o">.</span><span class="n">axis</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">frame</span>
              <span class="n">node</span><span class="o">.</span><span class="n">dof</span><span class="o">.</span><span class="n">rot</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></div></div>


<span class="c1"># construction d&#39;un avatar a partir d&#39;un maillage</span>
<div class="viewcode-block" id="buildMeshedAvatar"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.buildMeshedAvatar">[docs]</a><span class="k">def</span> <span class="nf">buildMeshedAvatar</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">material</span><span class="p">):</span>
   <span class="sd">&quot;&quot;&quot;buildMeshedAvatar(mesh, model, material):</span>

<span class="sd">   this function builds a meshed avatar from the mesh.</span>

<span class="sd">   parameters:</span>

<span class="sd">   - mesh: a given mesh</span>
<span class="sd">   - model: a given model</span>
<span class="sd">   - material: a given material</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">class_mesh</span><span class="p">):</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;The given mesh is not a mesh!&quot;</span><span class="p">)</span>

   <span class="c1"># on cree un avatar maille</span>
   <span class="n">body</span> <span class="o">=</span> <span class="n">avatar</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
   <span class="c1"># on renumerote les noeuds du maillage en utilisant leur rang</span>
   <span class="n">mesh</span><span class="o">.</span><span class="n">rankRenumbering</span><span class="p">()</span>
   <span class="c1"># on ajoute les noeuds du maillage a l&#39;avatar maille</span>
   <span class="n">body</span><span class="o">.</span><span class="n">addBulks</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">))</span>
   <span class="c1"># on ajoute les elements du maillage a l&#39;avatar maille</span>
   <span class="n">body</span><span class="o">.</span><span class="n">addNodes</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
   <span class="c1"># on definit les groupes pour l&#39;avatar maille</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineGroups</span><span class="p">()</span>
   <span class="c1"># on affecte son modele a l&#39;avatar maille</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineModel</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>
   <span class="c1"># on affecte son materiau a l&#39;avatar maille</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineMaterial</span><span class="p">(</span><span class="n">material</span><span class="o">=</span><span class="n">material</span><span class="p">)</span>

   <span class="c1"># on renvoie l&#39;avatar ainsi construit</span>
   <span class="k">return</span> <span class="n">body</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pylmgc90 2025.rc1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pylmgc90.pre.avatar.avatar</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2025, CNRS, UM.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>