
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pylmgc90.pre.build_avatar.mesh3D &#8212; pylmgc90 2025.rc1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinxdoc.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pylmgc90 2025.rc1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pylmgc90.pre.build_avatar.mesh3D</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pylmgc90.pre.build_avatar.mesh3D</h1><div class="highlight"><pre>
<span></span><span class="c1"># module qui fournit des macros pour construire et/ou manipuler des maillages 3D</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">..avatar.avatar</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">..avatar.bulk.element</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">..avatar.bulk.rigid3d</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">..avatar.contactor.rigid_properties_3D</span> <span class="kn">import</span> <span class="n">computeVolumeInertiaMesh</span>

<span class="kn">from</span> <span class="nn">.mesh</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">..avatars</span>  <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.particles</span> <span class="kn">import</span> <span class="n">rigidPolyhedron</span>

<span class="kn">from</span> <span class="nn">..utilities.error</span>    <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># import du module permettant de savoir si on pourra importer les pre_tools</span>
<span class="kn">from</span> <span class="nn">..utilities.check_compiled_modules</span> <span class="kn">import</span> <span class="o">*</span>


<span class="c1"># si on peut essayer d&#39;importer le module pre_tools sans tout faire planter</span>
<span class="k">if</span> <span class="n">import_lmgc90</span><span class="p">():</span>
   <span class="c1"># on essaye</span>
   <span class="k">try</span><span class="p">:</span>
      <span class="kn">from</span> <span class="nn">...chipy</span> <span class="kn">import</span> <span class="n">lmgc90</span>
   <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unable to import wrapped part surafcic mesh handling module!&#39;</span><span class="p">)</span>
      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;You will not be able to build polyhedron from surfacic meshes&#39;</span><span class="p">)</span>
   <span class="k">except</span><span class="p">:</span>
      <span class="k">raise</span>

<span class="c1"># connectivite des faces d&#39;un tetraedre (lineaire)</span>
<span class="n">faces_tetra</span><span class="o">=</span><span class="p">[</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">]</span>

<span class="c1"># connectivite des faces d&#39;un hexaedre (lineaire)</span>
<span class="n">faces_hexa</span><span class="o">=</span><span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
             <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
             <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
             <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
             <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
             <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="p">]</span>

<span class="c1"># connectivite des faces d&#39;un prisme (lineaire)</span>
<span class="n">faces_pri</span><span class="o">=</span><span class="p">[</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="p">]</span>

<span class="c1"># fonction qui extrait la surface libre d&#39;un maillage 3D volumique, sous la forme d&#39;un maillage 3D surfacique</span>
<span class="c1"># N.B.: les numeros des noeuds du maillage surfacique ne sont pas renumerotes</span>
<div class="viewcode-block" id="extractFreeSurface"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.extractFreeSurface">[docs]</a><span class="k">def</span> <span class="nf">extractFreeSurface</span><span class="p">(</span><span class="n">volumic_mesh</span><span class="p">):</span>
   <span class="sd">&quot;&quot;&quot;extractFreeSurface(volumic_mesh):</span>

<span class="sd">   this function computes and returns the free surface of a volumic mesh, as a</span>
<span class="sd">   surfacic mesh.</span>

<span class="sd">   N.B.: this function handles tetrahedra and prism</span>

<span class="sd">   parameters:</span>

<span class="sd">   - volumic_mesh: the given volumic mesh</span>

<span class="sd">   returned value: the built surfacic mesh</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="c1"># si le maillage volumique donne n&#39;est pas un maillage</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">volumic_mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
      <span class="c1"># on affiche un message d&#39;erreur</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given volumic mesh is not a mesh&quot;</span><span class="p">)</span>

   <span class="c1"># si le maillage n&#39;est pas defini avec de noeuds a trois dimensions</span>
   <span class="k">if</span> <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
      <span class="c1"># ca ne peut pas etre un maillage volumique!</span>
      <span class="c1"># on affiche un message d&#39;erreur </span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given mesh is 2D!&quot;</span><span class="p">)</span>

   <span class="c1"># numerotation des elements</span>

   <span class="c1"># on enumere les elements</span>
   <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">volumic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">):</span>
      <span class="c1"># on affecte l&#39;indice courant a l&#39;element courant</span>
      <span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="o">=</span><span class="n">num</span>

   <span class="c1"># construction des listes d&#39;adjacence de chaque noeud</span>

   <span class="c1"># on definit un container pour stocker les listes d&#39;adjacence de chaque </span>
   <span class="c1"># noeud </span>
   <span class="n">l_node2ele</span> <span class="o">=</span> <span class="p">{}</span>
   <span class="c1"># pour chaque noeud du corps, on intialise une liste d&#39;adjacence vide</span>
   <span class="k">for</span> <span class="n">nod</span> <span class="ow">in</span> <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
      <span class="n">l_node2ele</span><span class="p">[</span><span class="n">nod</span><span class="o">.</span><span class="n">number</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
   <span class="c1"># pour chaque element du maillage </span>
   <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># pour chaque noeud de l&#39;element</span>
      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
         <span class="c1"># on ajoute l&#39;element courant dans la liste d&#39;adjacence du noeud </span>
         <span class="c1"># courant</span>
         <span class="n">l_node2ele</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bulk</span><span class="p">)</span>
 
   <span class="c1"># extraction de la surface libre</span>
   
   <span class="c1"># on definit la liste des nombres de faces n&#39;appartenant pas a la surface libre, pour chaque element</span>
   <span class="n">nb_non_free_faces</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">volumic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">),</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span>
   <span class="c1"># on definit le dictionnaire qui indique pour chaque element, identifie par son numero, quelle face est libre</span>
   <span class="n">is_free_face</span><span class="o">=</span><span class="p">{}</span>
   <span class="c1"># pour chaque element</span>
   <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si l&#39;element est un element volumique</span>
      <span class="k">if</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
         <span class="c1"># si l&#39;element est un tetraedre</span>
         <span class="k">if</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;TE4xx&#39;</span><span class="p">:</span>
            <span class="c1"># on suppose que les quatre faces du tetraedre sont sur la surface libre</span>
            <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
            <span class="c1"># on recupere les numeros des noeuds du tetraedre</span>
            <span class="n">i1</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i2</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">i3</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">i4</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

            <span class="c1"># on teste d&#39;abord les faces qui portent le noeud i1 de l&#39;element courant</span>
            
            <span class="c1"># pour chaque element adjacent au noeud i1</span>
            <span class="k">for</span> <span class="n">adj_bulk</span> <span class="ow">in</span> <span class="n">l_node2ele</span><span class="p">[</span><span class="n">i1</span><span class="p">]:</span>
               <span class="c1"># si l&#39;element adjacent courant est l&#39;element courant</span>
               <span class="k">if</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">:</span>
                  <span class="c1"># on passe au suivant</span>
                  <span class="k">continue</span>
               <span class="c1"># si l&#39;element courant n&#39;est pas un tetraedre</span>
               <span class="k">if</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;TE4xx&#39;</span><span class="p">:</span>
                  <span class="c1"># on passe au suivant</span>
                  <span class="k">continue</span>

               <span class="c1"># si la face {i1, i2, i3} fait partie du prisme adjacent courant</span>
               <span class="k">if</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">i3</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                  <span class="c1"># on indique que la premiere face du tetraedre courant n&#39;appartient pas a la surface libre</span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de faces du tetraedre courant qui n&#39;appartiennent pas a la surface libre</span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
               <span class="c1"># si la face {i1, i2, i4} fait partie du tetraedre adjacent courant</span>
               <span class="k">if</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">i4</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                  <span class="c1"># on indique que la deuxieme face du tetraedre courant n&#39;appartient pas a la surface libre</span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de faces du tetraedre courant qui n&#39;appartiennent pas a la surface libre</span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
               <span class="c1"># si la face {i1, i3, i4} fait partie du tetraedre adjacent courant</span>
               <span class="k">if</span> <span class="n">i3</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">i4</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                  <span class="c1"># on indique que la quatrieme face du tetraedre courant n&#39;appartient pas a la surface libre</span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de faces du tetraedre courant qui n&#39;appartiennent pas a la surface libre</span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># on teste ensuite la derniere face de l&#39;element courant</span>
            
            <span class="c1"># pour chaque element adjacent au noeud i4</span>
            <span class="k">for</span> <span class="n">adj_bulk</span> <span class="ow">in</span> <span class="n">l_node2ele</span><span class="p">[</span><span class="n">i4</span><span class="p">]:</span>
               <span class="c1"># si l&#39;element adjacent courant est l&#39;element courant</span>
               <span class="k">if</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">:</span>
                  <span class="c1"># on passe au suivant</span>
                  <span class="k">continue</span>
               <span class="c1"># si l&#39;element courant n&#39;est pas un tetraedre</span>
               <span class="k">if</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;TE4xx&#39;</span><span class="p">:</span>
                  <span class="c1"># on passe au suivant</span>
                  <span class="k">continue</span>
               <span class="c1"># si la face {i4, i2, i3} fait partie du tetraedre adjacent courant</span>
               <span class="k">if</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">i3</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                  <span class="c1"># on indique que la troisieme face du tetraedre courant n&#39;appartient pas a la surface libre</span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de faces du tetraedre courant qui n&#39;appartiennent pas a la surface libre</span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

         <span class="k">elif</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;PRI6x&#39;</span><span class="p">:</span>

            <span class="c1"># on suppose que les faces sont sur la surface libre (ce commentaire est reellement debile)</span>
            <span class="c1"># par contre on ne test qu&#39;avec d&#39;autres pri6 !!</span>
            <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span>
            <span class="c1"># on recupere les numeros des noeuds</span>
            <span class="n">i1</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i2</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">i3</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">i4</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">i5</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="n">i6</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
            <span class="c1"># on teste d&#39;abord les faces qui portent le noeud i1 de l&#39;element courant</span>
            
            <span class="c1">#faces_pri=[ [4, 5, 6],</span>
            <span class="c1">#          [1, 2, 5, 4],</span>
            <span class="c1">#          [2, 3, 6, 5],</span>
            <span class="c1">#          [1, 3, 2],</span>
            <span class="c1">#          [1, 4, 6, 3] ]</span>

            <span class="c1"># pour chaque element adjacent au noeud i1</span>
            <span class="k">for</span> <span class="n">adj_bulk</span> <span class="ow">in</span> <span class="n">l_node2ele</span><span class="p">[</span><span class="n">i1</span><span class="p">]:</span>
               <span class="c1"># si l&#39;element adjacent courant est l&#39;element courant</span>
               <span class="k">if</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">:</span>
                  <span class="c1"># on passe au suivant</span>
                  <span class="k">continue</span>
                              
               <span class="c1"># on ne test qu&#39;avec des PRI6 ... a modifier.</span>
               <span class="k">if</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;PRI6x&#39;</span><span class="p">:</span>
                  <span class="k">continue</span>
               <span class="c1"># si la face {i1, i2, i5, i4} fait partie de l&#39;adjacent</span>
               <span class="k">if</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">i5</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">i4</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                  <span class="c1"># on la vire</span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de faces qui n&#39;appartiennent pas a la surface libre</span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
               <span class="c1"># si la face {i1, i3, i2} fait partie de l&#39;adjacent</span>
               <span class="k">if</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">i3</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                  <span class="c1"># on la vire</span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de faces qui n&#39;appartiennent pas a la surface libre</span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
               <span class="c1"># si la face {i1, i4, i6, i3} fait partie de l&#39;adjacent</span>
               <span class="k">if</span> <span class="n">i4</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">i6</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">i3</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                  <span class="c1"># on la vire</span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de faces qui n&#39;appartiennent pas a la surface libre</span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># pour chaque element adjacent au noeud i6</span>
            <span class="k">for</span> <span class="n">adj_bulk</span> <span class="ow">in</span> <span class="n">l_node2ele</span><span class="p">[</span><span class="n">i6</span><span class="p">]:</span>
               <span class="c1"># si l&#39;element adjacent courant est l&#39;element courant</span>
               <span class="k">if</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">:</span>
                  <span class="c1"># on passe au suivant</span>
                  <span class="k">continue</span>
               <span class="c1"># si l&#39;element courant n&#39;est pas un tetraedre</span>
               <span class="k">if</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;PRI6x&#39;</span><span class="p">:</span>
                  <span class="c1"># on passe au suivant</span>
                  <span class="k">continue</span>
               <span class="c1"># si la face {i4, i5, i6} fait partie de l&#39;adjacent</span>
               <span class="k">if</span> <span class="n">i4</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">i5</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                  <span class="c1"># on la vire</span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de faces qui n&#39;appartiennent pas a la surface libre</span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
               <span class="c1"># si la face {i2, i3, i6, i5} fait partie de l&#39;adjacent courant</span>
               <span class="k">if</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">i3</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">i5</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                  <span class="c1"># on la vire</span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de faces qui n&#39;appartiennent pas a la surface libre</span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

         <span class="c1"># si l&#39;element n&#39;est pas gere</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="c1">## on quitte le pgm</span>
            <span class="n">msg</span>  <span class="o">=</span> <span class="s2">&quot;no rigid can be built from this mesh, since it involves unhandled elements!&quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">+</span> <span class="s1">&#39; is not supported&#39;</span>
            <span class="n">showError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

   <span class="c1"># ici, on est sur que tous les elements volumiques du maillage sont pris en charge</span>

   <span class="c1">#</span>
   <span class="c1"># recuperation d&#39;une triangulation de la surface libre</span>
   <span class="c1">#</span>

   <span class="c1"># on declare un maillage pour stocker la triangulation de la surface libre</span>
   <span class="c1"># N.B.: le maillage est defini avec des neouds a trois dimensions, meme s&#39;il ne contient que des elements surfaciques</span>
   <span class="n">free_surface</span><span class="o">=</span><span class="n">mesh</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

   <span class="c1"># recuperation des elements de la surface libre</span>

   <span class="c1"># pour chaque element</span>
   <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si l&#39;element est un element volumique</span>
      <span class="k">if</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
         <span class="c1"># si l&#39;element est un tetraedre</span>
         <span class="k">if</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;TE4xx&#39;</span><span class="p">:</span>
            <span class="c1"># si aucune face du tetraedre appartient a la surface libre</span>
            <span class="k">if</span> <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
               <span class="c1"># on passe a l&#39;element suivant</span>
               <span class="k">continue</span>
            <span class="c1"># pour chaque face du tetraedre</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
               <span class="c1"># si la face courante est libre</span>
               <span class="k">if</span> <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
                  <span class="c1"># on recupere la connectivite de la face</span>
                  <span class="n">conn_free_face</span><span class="o">=</span><span class="p">[</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">faces_tetra</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> 
                                   <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">faces_tetra</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
                                   <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">faces_tetra</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span> <span class="p">]</span>
                  <span class="c1"># on ajoute la face a la liste des faces de la surface libre</span>
                  <span class="n">free_surface</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">conn_free_face</span><span class="p">)</span> <span class="p">)</span>
         <span class="k">elif</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;PRI6x&#39;</span><span class="p">:</span>
            <span class="c1"># si aucune face du tetraedre appartient a la surface libre</span>
            <span class="k">if</span> <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
               <span class="c1"># on passe a l&#39;element suivant</span>
               <span class="k">continue</span>
            <span class="c1"># pour chaque face du tetraedre</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
               <span class="c1"># si la face courante est libre</span>
               <span class="k">if</span> <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
                  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span> 
                    <span class="c1"># on recupere la connectivite de la face</span>
                    <span class="n">conn_free_face</span><span class="o">=</span><span class="p">[</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">faces_pri</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> 
                                     <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">faces_pri</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
                                     <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">faces_pri</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span> <span class="p">]</span>
                    <span class="c1"># on ajoute la face a la liste des faces de la surface libre</span>
                    <span class="n">free_surface</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">conn_free_face</span><span class="p">)</span> <span class="p">)</span>
                  <span class="k">else</span><span class="p">:</span>

                    <span class="c1">#print i</span>
                    <span class="c1">#print faces_pri[i][:]</span>
                    <span class="c1">#print bulk.connectivity[faces_pri[i][0]],bulk.connectivity[faces_pri[i][1]],bulk.connectivity[faces_pri[i][2]],bulk.connectivity[faces_pri[i][3]]</span>
                    <span class="c1"># on recupere la connectivite de la face</span>
                    <span class="n">conn_free_face</span><span class="o">=</span><span class="p">[</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">faces_pri</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> 
                                     <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">faces_pri</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
                                     <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">faces_pri</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]],</span>
                                     <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">faces_pri</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span> <span class="p">]</span>
                    <span class="c1"># on ajoute la face a la liste des faces de la surface libre</span>
                    <span class="n">free_surface</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">conn_free_face</span><span class="p">)</span> <span class="p">)</span>
                      
   <span class="c1"># recuperation des noeuds de la surface libre</span>

   <span class="c1"># on declare la liste des numeros de noeuds de la surface libre</span>
   <span class="n">free_node_numbers</span><span class="o">=</span><span class="p">[]</span>
   <span class="c1"># pour chaque face de la surface libre</span>
   <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">free_surface</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># pour chaque noeud de la table de connectivite de la face</span>
      <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="n">face</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
         <span class="c1"># si le noeud n&#39;a pas deja ete visite</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">number</span> <span class="ow">in</span> <span class="n">free_node_numbers</span><span class="p">:</span>
            <span class="c1"># on ajoute le numero du noeud courant a la liste des numeors de noeuds de la surface libre</span>
            <span class="n">free_node_numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
            <span class="c1"># on ajoute une copie du noeud au maillage de la surface libre</span>
            <span class="n">free_surface</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">volumic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">number</span><span class="p">]))</span>

   <span class="c1"># on renvoie le maillage de la surface libre</span>
   <span class="k">return</span> <span class="n">free_surface</span></div>

<span class="c1"># fonction qui reoriente les elements surfacique d&#39;un maillage 3D, en se servant de l&#39;orientation des elements volumiques</span>
<div class="viewcode-block" id="reorientSurfacicElements"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.reorientSurfacicElements">[docs]</a><span class="k">def</span> <span class="nf">reorientSurfacicElements</span><span class="p">(</span><span class="n">volumic_mesh</span><span class="p">):</span> 
   <span class="sd">&quot;&quot;&quot;reorientSurfacicElements(volumic_mesh):</span>

<span class="sd">   this function reorient surfacic elements of a 3D mesh, using orientation of volumic elements</span>

<span class="sd">   N.B.: this function only handle tetrahedra</span>

<span class="sd">   parameters:</span>

<span class="sd">   - volumic_mesh: the given volumic mesh</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="c1"># si le maillage volumique donne n&#39;est pas un maillage</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">volumic_mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
      <span class="c1"># on affiche un message d&#39;erreur</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given volumic mesh is not a mesh&quot;</span><span class="p">)</span>

   <span class="c1"># si le maillage n&#39;est pas defini avec de noeuds a trois dimensions</span>
   <span class="k">if</span> <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
      <span class="c1"># ca ne peut pas etre un maillage volumique!</span>
      <span class="c1"># on affiche un message d&#39;erreur </span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given mesh is 2D!&quot;</span><span class="p">)</span>

   <span class="c1"># extraction de la surface libre</span>
   <span class="n">free_surface</span><span class="o">=</span><span class="n">extractFreeSurface</span><span class="p">(</span><span class="n">volumic_mesh</span><span class="p">)</span>

   <span class="c1"># construction des listes d&#39;adjacence de chaque noeud, dans le maillage de la surface libre</span>

   <span class="c1"># on definit un container pour stocker les listes d&#39;adjacence de chaque </span>
   <span class="c1"># noeud </span>
   <span class="n">l_node2ele</span> <span class="o">=</span> <span class="p">{}</span>
   <span class="c1"># pour chaque noeud du corps, on intialise une liste d&#39;adjacence vide</span>
   <span class="k">for</span> <span class="n">nod</span> <span class="ow">in</span> <span class="n">free_surface</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
      <span class="n">l_node2ele</span><span class="p">[</span><span class="n">nod</span><span class="o">.</span><span class="n">number</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
   <span class="c1"># pour chaque element de la surface libre</span>
   <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="n">free_surface</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># pour chaque noeud de l&#39;element</span>
      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
         <span class="c1"># on ajoute l&#39;element courant dans la liste d&#39;adjacence du noeud </span>
         <span class="c1"># courant</span>
         <span class="n">l_node2ele</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bulk</span><span class="p">)</span>

   <span class="c1"># reorientation des elements surfaciques</span>
   
   <span class="c1"># pour chaque element du maillage</span>
   <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si l&#39;element est un element surfacique</span>
      <span class="k">if</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
         <span class="c1"># on recupere la connectivite de l&#39;element courant</span>
         <span class="n">connectivity</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span>
  
         <span class="c1">#print &quot;original connectivity: &quot;, bulk.connectivity</span>

         <span class="c1"># pour chaque element adjacent au premier noeud de l&#39;element courant (dans la surface libre)</span>
         <span class="k">for</span> <span class="n">free_bulk</span> <span class="ow">in</span> <span class="n">l_node2ele</span><span class="p">[</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
            <span class="c1"># on suppose que l&#39;element de la surface libre courant corespond a l&#39;element surfacique courant</span>
            <span class="n">is_found</span><span class="o">=</span><span class="kc">True</span>
            <span class="c1"># pour chaque noeud de l&#39;element de la surface libre courant</span>
            <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">free_bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
               <span class="c1"># si le numero de noeud courant n&#39;est pas support de l&#39;element surfacique courant</span>
               <span class="k">if</span> <span class="ow">not</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="p">:</span>
                  <span class="c1"># l&#39;element de la surface libre courant ne peut pas corespondre a l&#39;element surfacique courant</span>
                  <span class="n">is_found</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on sort de la boucle</span>
                  <span class="k">break</span>
            <span class="c1"># si l&#39;element de la surface libre courant est associe a l&#39;element surfacique courant</span>
            <span class="k">if</span> <span class="n">is_found</span><span class="p">:</span>
               <span class="c1"># la connectivite de l&#39;element de la surface libre remplace la connectivite de l&#39;element surfacique courant</span>
               <span class="c1"># (et l&#39;orientation de l&#39;element surfacique courant suit l&#39;orientation de l&#39;element de la surface libre)</span>
               <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="o">=</span><span class="n">free_bulk</span><span class="o">.</span><span class="n">connectivity</span>
               <span class="c1"># on passe au prochain element surfacique</span>
               <span class="k">break</span>
         <span class="c1"># si on n&#39;a pas trouve l&#39;element de la surface libre corespondant a l&#39;element surfacique courant</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">is_found</span><span class="p">:</span>
            <span class="c1"># il y a un (gros) probleme de coherence entre les elements surfaciques et la surface libre</span>
            <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;inconsistency between volumic and the free surface!&quot;</span><span class="p">)</span></div>
         
         <span class="c1">#print &quot;new connectivity: &quot;, bulk.connectivity</span>

<span class="c1"># fonction qui construit un corps rigide a partir d&#39;un maillage 3D, decrit comme un ensemble de noeuds et </span>
<span class="c1"># un ensemble d&#39;elements</span>
<div class="viewcode-block" id="volumicMeshToRigid3D"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.volumicMeshToRigid3D">[docs]</a><span class="k">def</span> <span class="nf">volumicMeshToRigid3D</span><span class="p">(</span><span class="n">volumic_mesh</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;BLUEx&#39;</span><span class="p">):</span>
   <span class="sd">&quot;&quot;&quot;volumicMeshToRigid3D(volumic_mesh, model, material, color=&#39;BLUEx&#39;):</span>

<span class="sd">   this function builds a rigid body from a volumic mesh, by extracting the skin mesh and compute mass and inertia</span>
<span class="sd">   from volumic elements.</span>

<span class="sd">   N.B.: this function only handle tetrahedra</span>

<span class="sd">   parameters:</span>

<span class="sd">   - volumic_mesh: the given volumic mesh</span>
<span class="sd">   - model: a given model</span>
<span class="sd">   - material: a given material</span>

<span class="sd">   optional parameters:</span>

<span class="sd">   - color=&#39;BLUEx&#39;: color of the polyhedron contactor</span>

<span class="sd">   returned value: the built rigid body</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="c1"># si le maillage volumique donne n&#39;est pas un maillage</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">volumic_mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
      <span class="c1"># on affiche un message d&#39;erreur</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given volumic mesh is not a mesh&quot;</span><span class="p">)</span>

   <span class="c1"># si le maillage n&#39;est pas defini avec de noeuds a trois dimensions</span>
   <span class="k">if</span> <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
      <span class="c1"># ca ne peut pas etre un maillage volumique!</span>
      <span class="c1"># on affiche un message d&#39;erreur </span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given mesh is 2D!&quot;</span><span class="p">)</span>

   <span class="c1"># on verifie que le maillage ne contient bien des elements volumiques</span>

   <span class="c1"># on initialise le nombre d&#39;elements volumiques a 0</span>
   <span class="n">nb_volumic_bulks</span><span class="o">=</span><span class="mi">0</span>
   <span class="c1"># pour chaque element</span>
   <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si l&#39;element est un element volumique</span>
      <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
         <span class="c1"># on incremente le nombre d&#39;elements volumiques</span>
         <span class="n">nb_volumic_bulks</span> <span class="o">+=</span> <span class="mi">1</span>

   <span class="c1"># si le maillage ne contient aucun element volumique</span>
   <span class="k">if</span> <span class="n">nb_volumic_bulks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c1"># on affiche un message d&#39;erreur</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given mesh contains no volumic element!&quot;</span><span class="p">)</span>
 
   <span class="c1">#</span>
   <span class="c1"># creation de l&#39;avatar rigide</span>
   <span class="c1">#</span>

   <span class="c1"># on declare le nouvel avatar</span>
   <span class="n">body</span><span class="o">=</span><span class="n">avatar</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
   <span class="c1"># on positionne le centre d&#39;inertie du rigide a l&#39;origine, pour pouvoir</span>
   <span class="c1"># donner les coordonnees des sommets du polyedre dans le repere global</span>
   <span class="n">body</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span> <span class="n">node</span><span class="p">(</span> <span class="n">coor</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
   <span class="c1"># on cree un comportement volumique pour le corps</span>
   <span class="n">body</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">rigid3d</span><span class="p">()</span> <span class="p">)</span>
   <span class="c1"># on definit les groupes pour l&#39;avatar</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineGroups</span><span class="p">()</span>
   <span class="c1"># on affecte son modele a l&#39;avatar</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineModel</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>      
   <span class="c1"># on affecte son materiau a l&#39;avatar</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineMaterial</span><span class="p">(</span><span class="n">material</span><span class="o">=</span><span class="n">material</span><span class="p">)</span>

   <span class="c1">#</span>
   <span class="c1"># construction du contacteur polyedre</span>
   <span class="c1">#</span>

   <span class="c1"># extraction de la surface libre</span>
   <span class="n">free_surface</span><span class="o">=</span><span class="n">extractFreeSurface</span><span class="p">(</span><span class="n">volumic_mesh</span><span class="p">)</span>

   <span class="c1"># on renumerote des noeuds de la surface libre</span>
   <span class="n">free_surface</span><span class="o">.</span><span class="n">rankRenumbering</span><span class="p">()</span>

   <span class="c1"># on stocke les coordonnees des noeuds de la surface libre dans une liste</span>

   <span class="c1"># on recupere la liste triee des numeros de noeuds de la surface libre</span>
   <span class="n">sorted_node_numbers</span><span class="o">=</span><span class="n">free_surface</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">sortedKeys</span><span class="p">()</span>
   <span class="n">l_free_coor</span><span class="o">=</span><span class="p">[]</span>
   <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">sorted_node_numbers</span><span class="p">:</span>
      <span class="n">l_free_coor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">free_surface</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">coor</span><span class="p">)</span>

   <span class="c1"># on stocke les connectivites des faces des triangles de la surface libre dans une liste</span>
   <span class="n">l_free_conn</span><span class="o">=</span><span class="p">[</span><span class="n">face</span><span class="o">.</span><span class="n">connectivity</span> <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">free_surface</span><span class="o">.</span><span class="n">bulks</span><span class="p">]</span> 

   <span class="c1"># calcul du volume, de l&#39;inertie et de la position du centre d&#39;inertie du contacteur polyedre</span>
   <span class="n">volume</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">OG</span><span class="o">=</span><span class="n">computeVolumeInertiaMesh</span><span class="p">(</span><span class="n">volumic_mesh</span><span class="p">)</span>

   <span class="c1"># on ajoute son contacteur polyedre a l&#39;avatar</span>
   <span class="n">body</span><span class="o">.</span><span class="n">addContactors</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="s1">&#39;POLYR&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="n">OG</span><span class="p">,</span>
      <span class="n">nb_vertices</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">l_free_coor</span><span class="p">),</span> <span class="n">nb_faces</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">l_free_conn</span><span class="p">),</span> 
      <span class="n">vertices</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l_free_coor</span><span class="p">),</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l_free_conn</span><span class="p">))</span>

   <span class="c1"># calcul du volume et de l&#39;inertie du corps (a partir du volume et de l&#39;inertie </span>
   <span class="c1"># du polyedre)</span>
   <span class="n">body</span><span class="o">.</span><span class="n">computeRigidProperties</span><span class="p">()</span>
 
   <span class="c1"># on renvoie le corps genere</span>
   <span class="k">return</span> <span class="n">body</span></div>

<span class="c1"># fonction qui affecte un numero d&#39;entite aux elements d&#39;un maillage de surface, en fonction de la composante connexe a laquelle ils appartiennent</span>
<span class="k">def</span> <span class="nf">identifyEntitiesInSurfacicMesh</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="p">):</span>
   <span class="sd">&quot;&quot;&quot;identifyEntitiesInSurfacicMesh(surfacic_mesh):</span>

<span class="sd">   this  function attributes an entity value to triangle elements, by computing </span>
<span class="sd">   connected components. This new entity value replaces the geometricalEntity of</span>
<span class="sd">   triangle elements.</span>

<span class="sd">   N.B.: this function only handle triangles</span>

<span class="sd">   parameters:</span>

<span class="sd">   - surfacic_mesh: the given surfacic mesh</span>

<span class="sd">   returned value: None</span>
<span class="sd">   &quot;&quot;&quot;</span>

   <span class="c1"># si le maillage surfacique donne n&#39;est pas un maillage</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
      <span class="c1"># on affiche un message d&#39;erreur</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given surfacic mesh is not a mesh&quot;</span><span class="p">)</span>

   <span class="c1"># si le maillage n&#39;est pas defini avec des noeuds a trois dimensions</span>
   <span class="k">if</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
      <span class="c1"># ca ne peut pas servir a la construction d&#39;un avatar 3D!</span>
      <span class="c1"># on affiche un message d&#39;erreur </span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given mesh is 2D!&quot;</span><span class="p">)</span>

   <span class="c1"># on verifie que le maillage ne contient que des triangles a trois noeuds</span>
   <span class="c1"># et on contruit la liste des numeros des elements T3xxx</span>
 
   <span class="c1"># on initialise la liste des numeros des elements T3xxx a vide</span>
   <span class="n">ind_T3</span><span class="o">=</span><span class="p">[]</span>
   <span class="c1"># on initialise le nombre d&#39;elements T3xxx a 0</span>
   <span class="n">nb_bulks_T3</span><span class="o">=</span><span class="mi">0</span>
   <span class="c1"># pour chaque element</span>
   <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ele</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">):</span>
      <span class="c1"># si l&#39;element est un element volumique</span>
      <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
         <span class="c1"># on affiche un message d&#39;erreur</span>
         <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given mesh is not a surfacic mesh&quot;</span><span class="p">)</span>
      <span class="c1"># sinon, si l&#39;element est un point ou une ligne</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
         <span class="c1"># on passe au suivant</span>
         <span class="k">continue</span>
      <span class="c1"># si l&#39;element courant est un element surfacique, mais n&#39;est pas un triangle a trois noeuds</span>
      <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;T3xxx&#39;</span><span class="p">:</span>
         <span class="c1"># on affiche un message d&#39;erreur</span>
         <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given surfacic mesh contains unhandled elements!&quot;</span><span class="p">)</span>
      <span class="c1"># sinon, </span>
      <span class="k">else</span><span class="p">:</span>
         <span class="c1"># on ajoute le numero de l&#39;element courant a la liste</span>
         <span class="n">ind_T3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
         <span class="c1"># on incremente le nombre d&#39;elements triangle</span>
         <span class="n">nb_bulks_T3</span> <span class="o">+=</span> <span class="mi">1</span>

   <span class="c1"># si le maillage ne contient aucun triangle</span>
   <span class="k">if</span> <span class="n">nb_bulks_T3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c1"># on affiche un message d&#39;erreur</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given surfacic mesh contains no T3!&quot;</span><span class="p">)</span>
  
   <span class="c1"># ici on est sur que le maillage ne contient que des triangles</span>
   <span class="c1"># (et eventuellement des lignes ou des points...)</span>

   <span class="c1"># on recupere le nombre de noeuds du maillage</span>
   <span class="n">nb_nodes</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>

   <span class="c1"># on compte le nombre d&#39;elements triangles adjacents a chaque noeud</span>
   
   <span class="c1"># on initialise a 0 un vecteur d&#39;entiers pour stocker le nombre d&#39;elements triangles adjacents a chaque noeud</span>
   <span class="n">nb_ele_adj</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nb_nodes</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span> 
   <span class="c1"># pour chaque triangle</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_bulks_T3</span><span class="p">):</span>
      <span class="c1"># pour chaque noeud de l&#39;element courant</span>
      <span class="k">for</span> <span class="n">i_nod</span> <span class="ow">in</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">ind_T3</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
         <span class="c1"># on incremente le nombre d&#39;elements adjacents au noeud courant</span>
         <span class="n">nb_ele_adj</span><span class="p">[</span><span class="n">i_nod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

   <span class="c1"># on recupere le nombre maximal d&#39;elements adjacents a un noeud</span>
   <span class="n">max_nb_ele_adj</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">nb_ele_adj</span><span class="p">)</span>
   <span class="c1"># on le passe du format int32, utilise par numpy, au format int standard de Python</span>
   <span class="n">max_nb_ele_adj</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">max_nb_ele_adj</span><span class="p">)</span>

   <span class="c1"># on recupere les connectivites de tous les triangles dans un vecteur</span>

   <span class="c1"># on declare un vecteur a la bonne taille</span>
   <span class="n">connec</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">nb_bulks_T3</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span>
   <span class="c1"># on initialise l&#39;indice de l&#39;element triangle courant a 0</span>
   <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
   <span class="c1"># pour chaque element</span>
   <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si l&#39;element courant est un triangle</span>
      <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;T3xxx&#39;</span><span class="p">:</span>
         <span class="c1"># on stocke sa connectivite</span>
         <span class="n">connec</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">=</span><span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span>
         <span class="c1"># on incremente l&#39;indice de l&#39;element triangle courant</span>
         <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

   <span class="c1"># on attribue une entite a chaque element par une recherche de composantes connexes</span>
   <span class="n">ele2entity</span><span class="o">=</span><span class="n">lmgc90</span><span class="o">.</span><span class="n">surface_T3_identify_entities</span><span class="p">(</span><span class="n">nb_nodes</span><span class="p">,</span> <span class="n">max_nb_ele_adj</span><span class="p">,</span> <span class="n">connec</span><span class="p">,</span> <span class="n">nb_bulks_T3</span><span class="p">)</span>

   <span class="c1"># pour chaque element triangle</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_bulks_T3</span><span class="p">):</span>
      <span class="c1"># on remplace la valeur de l&#39;entite geometrique par la valeur d&#39;entite obtenue precedemment</span>
      <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">ind_T3</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">geometricalEntity</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">ele2entity</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="c1"># fonction qui construit un corps rigide a partir d&#39;un maillage de surface 3D, decrit comme un ensemble de noeuds et </span>
<span class="c1"># un ensemble d&#39;elements</span>
<div class="viewcode-block" id="surfacicMeshToRigid3D"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.surfacicMeshToRigid3D">[docs]</a><span class="k">def</span> <span class="nf">surfacicMeshToRigid3D</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;BLUEx&#39;</span><span class="p">):</span>
   <span class="sd">&quot;&quot;&quot;surfacicMeshToRigid3D(surfacic_mesh, model, material, color=&#39;BLUEx&#39;):</span>

<span class="sd">   this function builds a rigid body from a surfacic mesh, by computing mass and inertia</span>
<span class="sd">   from surfacic elements (amazing, isn&#39;t it ^^).</span>

<span class="sd">   N.B.: this function only handle triangles</span>

<span class="sd">   parameters:</span>

<span class="sd">   - surfacic_mesh: the given surfacic mesh</span>
<span class="sd">   - model: a given model</span>
<span class="sd">   - material: a given material</span>

<span class="sd">   optional parameters:</span>

<span class="sd">   - color=&#39;BLUEx&#39;: color of the polyhedron contactor</span>

<span class="sd">   returned value: the built rigid body</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="c1"># si le maillage surfacique donne n&#39;est pas un maillage</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
      <span class="c1"># on affiche un message d&#39;erreur</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given surfacic mesh is not a mesh&quot;</span><span class="p">)</span>

   <span class="c1"># si le maillage n&#39;est pas defini avec de noeuds a trois dimensions</span>
   <span class="k">if</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
      <span class="c1"># ca ne peut pas servir a la construction d&#39;un avatar 3D!</span>
      <span class="c1"># on affiche un message d&#39;erreur </span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given mesh is 2D!&quot;</span><span class="p">)</span>

   <span class="c1"># on verifie que le maillage ne contient que des triangles a trois noeuds</span>

   <span class="c1"># on initialise le nombre d&#39;elements triangle a 0</span>
   <span class="n">nb_bulks_T3</span><span class="o">=</span><span class="mi">0</span>
   <span class="c1"># pour chaque element</span>
   <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si l&#39;element est un element volumique</span>
      <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
         <span class="c1"># on affiche un message d&#39;erreur</span>
         <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given mesh is not a surfacic mesh&quot;</span><span class="p">)</span>
      <span class="c1"># sinon, si l&#39;element est un point ou une ligne</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
         <span class="c1"># on passe au suivant</span>
         <span class="k">continue</span>
      <span class="c1"># si l&#39;element courant est un element surfacique, mais n&#39;est pas un triangle a trois noeuds</span>
      <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;T3xxx&#39;</span><span class="p">:</span>
         <span class="c1"># on affiche un message d&#39;erreur</span>
         <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given surfacic mesh contains unhandled elements!&quot;</span><span class="p">)</span>
      <span class="c1"># sinon, </span>
      <span class="k">else</span><span class="p">:</span>
         <span class="c1"># on incremente le nombre d&#39;elements triangles</span>
         <span class="n">nb_bulks_T3</span> <span class="o">+=</span> <span class="mi">1</span>

   <span class="c1"># si le maillage ne contient aucun triangle</span>
   <span class="k">if</span> <span class="n">nb_bulks_T3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c1"># on affiche un message d&#39;erreur</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given surfacic mesh contains no T3!&quot;</span><span class="p">)</span>
  
   <span class="c1"># ici on est sur que le maillage ne contient que des triangles</span>
   <span class="c1"># (et eventuellement des lignes ou des points...)</span>

   <span class="c1">#</span>
   <span class="c1"># creation de l&#39;avatar rigide</span>
   <span class="c1">#</span>

   <span class="c1"># on declare le nouvel avatar</span>
   <span class="n">body</span><span class="o">=</span><span class="n">avatar</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
   <span class="c1"># on positionne le centre d&#39;inertie du rigide a l&#39;origine, pour pouvoir</span>
   <span class="c1"># donner les coordonnees des sommets du polyedre dans le repere global</span>
   <span class="n">body</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span> <span class="n">node</span><span class="p">(</span> <span class="n">coor</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
   <span class="c1"># on cree un comportement volumique pour le corps</span>
   <span class="n">body</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">rigid3d</span><span class="p">()</span> <span class="p">)</span>
   <span class="c1"># on definit les groupes pour l&#39;avatar</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineGroups</span><span class="p">()</span>
   <span class="c1"># on affecte son modele a l&#39;avatar</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineModel</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>      
   <span class="c1"># on affecte son materiau a l&#39;avatar</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineMaterial</span><span class="p">(</span><span class="n">material</span><span class="o">=</span><span class="n">material</span><span class="p">)</span>

   <span class="c1">#</span>
   <span class="c1"># construction du contacteur polyedre</span>
   <span class="c1">#</span>

   <span class="c1"># on renumerote les noeuds du maillage en utilisant leur rang</span>
   <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">rankRenumbering</span><span class="p">()</span>

   <span class="c1"># on recupere le nombre de noeuds</span>
   <span class="n">nb_nodes</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
  
   <span class="c1"># on stocke le maillage de surface dans deux vecteurs :</span>
   <span class="c1">#   * les coordonnees</span>
   <span class="c1"># on declare un vecteur a la bonne taille</span>
   <span class="n">coor</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">nb_nodes</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
   <span class="c1"># on enumere les noeuds</span>
   <span class="k">for</span> <span class="n">nod</span> <span class="ow">in</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
      <span class="c1"># on stocke les coordonnees du noeud courant</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">nod</span><span class="o">.</span><span class="n">number</span><span class="o">-</span><span class="mi">1</span>
      <span class="n">coor</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">=</span><span class="n">nod</span><span class="o">.</span><span class="n">coor</span>
   <span class="c1">#   * les connectivites</span>
   <span class="c1"># on declare un vecteur a la bonne taille</span>
   <span class="n">connec</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">nb_bulks_T3</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span>
   <span class="c1"># on initialise l&#39;indice de l&#39;element triangle courant a 0</span>
   <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
   <span class="c1"># pour chaque element</span>
   <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si l&#39;element courant est un triangle</span>
      <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;T3xxx&#39;</span><span class="p">:</span>
         <span class="c1"># on stocke sa connectivite</span>
         <span class="n">connec</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">=</span><span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span>
         <span class="c1"># on incremente l&#39;indice de l&#39;element triangle courant</span>
         <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

   <span class="c1"># on calcule le volume de l&#39;objet a partir de sa surface</span>
   <span class="n">OG</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">lmgc90</span><span class="o">.</span><span class="n">surface_T3_compute_volume_inertia</span><span class="p">(</span><span class="n">coor</span><span class="p">,</span> <span class="n">connec</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>

   <span class="c1"># on rend a la matrice d&#39;inertie sa forme de matrice 3x3</span>
   <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

   <span class="c1"># on donne a la liste des coordonnees des noeuds et aux tables de connectivite la forme voulue</span>
   <span class="c1"># pour construire un polyedre </span>
   <span class="n">coor</span><span class="o">=</span><span class="n">coor</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">nb_nodes</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
   <span class="n">connec</span><span class="o">=</span><span class="n">connec</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">nb_bulks_T3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

   <span class="c1"># on ajoute son contacteur polyedre a l&#39;avatar</span>
   <span class="n">body</span><span class="o">.</span><span class="n">addContactors</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="s1">&#39;POLYR&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="n">OG</span><span class="p">,</span>
      <span class="n">nb_vertices</span><span class="o">=</span><span class="n">nb_nodes</span><span class="p">,</span> <span class="n">nb_faces</span><span class="o">=</span><span class="n">nb_bulks_T3</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="n">coor</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connec</span><span class="p">)</span>

   <span class="c1"># calcul du volume et de l&#39;inertie du corps (a partir du volume et de l&#39;inertie </span>
   <span class="c1"># du polyedre)</span>
   <span class="n">body</span><span class="o">.</span><span class="n">computeRigidProperties</span><span class="p">()</span>

   <span class="c1"># on renvoie le corps genere</span>
   <span class="k">return</span> <span class="n">body</span></div>

<span class="c1"># fonction qui construit un corps rigide a partir d&#39;un ensemble de surface 3D,</span>
<span class="c1"># decrit comme un ensemble de noeuds et un ensemble d&#39;elements</span>
<div class="viewcode-block" id="surfacicMeshesToRigid3D"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.surfacicMeshesToRigid3D">[docs]</a><span class="k">def</span> <span class="nf">surfacicMeshesToRigid3D</span><span class="p">(</span><span class="n">surfacic_meshes</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;BLUEx&#39;</span><span class="p">,</span><span class="n">reverse</span><span class="o">=</span><span class="s1">&#39;no&#39;</span><span class="p">):</span>
   <span class="sd">&quot;&quot;&quot;surfacicMeshesToRigid3D(surfacic_meshes, model, material, color=&#39;BLUEx&#39;):</span>

<span class="sd">   this function builds a rigid body from a list of surfacic mesh, by computing mass and inertia</span>
<span class="sd">   from surfacic elements </span>

<span class="sd">   N.B.: this function only handle triangles</span>

<span class="sd">   parameters:</span>

<span class="sd">   - surfacic_mesh: the given list of surfacic meshes</span>
<span class="sd">   - model: a given model</span>
<span class="sd">   - material: a given material</span>

<span class="sd">   optional parameters:</span>

<span class="sd">   - color=&#39;BLUEx&#39;: color of the polyhedron contactor (aka POLYF)</span>

<span class="sd">   returned value: the built rigid body</span>
<span class="sd">   &quot;&quot;&quot;</span>

   <span class="c1"># on declare le nouvel avatar</span>
   <span class="n">body</span><span class="o">=</span><span class="n">avatar</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
   <span class="c1"># on positionne le centre d&#39;inertie du rigide a l&#39;origine, pour pouvoir</span>
   <span class="c1"># donner les coordonnees des sommets du polyedre dans le repere global</span>
   <span class="n">body</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span> <span class="n">node</span><span class="p">(</span> <span class="n">coor</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
   <span class="c1"># on cree un comportement volumique pour le corps</span>
   <span class="n">body</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">rigid3d</span><span class="p">()</span> <span class="p">)</span>
   <span class="c1"># on definit les groupes pour l&#39;avatar</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineGroups</span><span class="p">()</span>
   <span class="c1"># on affecte son modele a l&#39;avatar</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineModel</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>      
   <span class="c1"># on affecte son materiau a l&#39;avatar</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineMaterial</span><span class="p">(</span><span class="n">material</span><span class="o">=</span><span class="n">material</span><span class="p">)</span>


   <span class="c1"># si le maillage surfacique donne n&#39;est pas un maillage</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surfacic_meshes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given geometry is not a list of mesh&quot;</span><span class="p">)</span>

   <span class="c1"># on fait les verifs de conformites des structures de donnees</span>
   <span class="c1"># on compte le nombre de noeuds et d&#39;elements de la liste de maillage</span>
   <span class="n">nb_nodes</span><span class="o">=</span><span class="mi">0</span>
   <span class="n">nb_elements</span><span class="o">=</span><span class="mi">0</span>
   <span class="k">for</span> <span class="n">surfacic_mesh</span> <span class="ow">in</span> <span class="n">surfacic_meshes</span><span class="p">:</span>
     <span class="c1">#print surfacic_mesh</span>
     <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
        <span class="c1"># on affiche un message d&#39;erreur</span>
        <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given surfacic mesh is not a mesh&quot;</span><span class="p">)</span>

     <span class="c1"># si le maillage n&#39;est pas defini avec de noeuds a trois dimensions</span>
     <span class="k">if</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># ca ne peut pas servir a la construction d&#39;un avatar 3D!</span>
        <span class="c1"># on affiche un message d&#39;erreur </span>
        <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given mesh is 2D!&quot;</span><span class="p">)</span>

     <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">rankRenumbering</span><span class="p">()</span>
     <span class="n">nb_nodes</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
     <span class="c1"># on verifie que le maillage ne contient que des triangles a trois noeuds</span>

     <span class="c1"># on initialise le nombre d&#39;elements triangle a 0</span>
     <span class="n">nb_bulks_T3</span><span class="o">=</span><span class="mi">0</span>
     <span class="c1"># pour chaque element</span>
     <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
        <span class="c1"># si l&#39;element est un element volumique</span>
        <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given mesh is not a surfacic mesh&quot;</span><span class="p">)</span>
        <span class="c1"># sinon, si l&#39;element est un point ou une ligne</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
           <span class="c1"># on passe au suivant</span>
           <span class="k">continue</span>
        <span class="c1"># si l&#39;element courant est un element surfacique, mais n&#39;est pas un triangle a trois noeuds</span>
        <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;T3xxx&#39;</span><span class="p">:</span>
           <span class="c1"># on affiche un message d&#39;erreur</span>
           <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given surfacic mesh contains unhandled elements!&quot;</span><span class="p">)</span>
        <span class="c1"># sinon, </span>
        <span class="k">else</span><span class="p">:</span>
           <span class="c1"># on incremente le nombre d&#39;elements triangles</span>
           <span class="n">nb_bulks_T3</span> <span class="o">+=</span> <span class="mi">1</span>

     <span class="c1"># si le maillage ne contient aucun triangle</span>
     <span class="k">if</span> <span class="n">nb_bulks_T3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># on affiche un message d&#39;erreur</span>
        <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given surfacic mesh contains no T3!&quot;</span><span class="p">)</span>
  
     <span class="c1"># ici on est sur que le maillage ne contient que des triangles</span>
     <span class="c1"># (et eventuellement des lignes ou des points...)</span>

     <span class="n">nb_elements</span> <span class="o">+=</span> <span class="n">nb_bulks_T3</span> 


   <span class="n">coor</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">nb_nodes</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
   <span class="n">connec</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">nb_elements</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span>

   <span class="n">nb_nodes</span><span class="o">=</span><span class="mi">0</span>
   <span class="n">nb_elements</span><span class="o">=</span><span class="mi">0</span>
   <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">surfacic_mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">surfacic_meshes</span><span class="p">):</span>

     <span class="c1">#print &#39;patch &#39;,k</span>

     <span class="c1">#</span>
     <span class="c1"># construction du contacteur polyedre</span>
     <span class="c1">#</span>
     <span class="c1"># coordonnees</span>
     <span class="k">for</span> <span class="n">nod</span> <span class="ow">in</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">nod</span><span class="o">.</span><span class="n">number</span><span class="o">-</span><span class="mi">1</span>
        <span class="c1">#print(&#39;ajout du noeud &#39;,nb_nodes+i,&#39; : &#39;,nod.coor)</span>
        <span class="n">coor</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">nb_nodes</span><span class="o">+</span><span class="n">i</span><span class="p">):</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">nb_nodes</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">=</span><span class="n">nod</span><span class="o">.</span><span class="n">coor</span>

     <span class="k">if</span> <span class="n">reverse</span> <span class="o">==</span> <span class="s1">&#39;yes&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
          <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

     <span class="c1"># les connectivites</span>
     <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
     <span class="c1"># pour chaque element</span>
     <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
        <span class="c1"># si l&#39;element courant est un triangle</span>
        <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;T3xxx&#39;</span><span class="p">:</span>
           <span class="c1">#print(&#39;ajout de l element &#39;,nb_elements+i,&#39; : &#39;, [x+nb_nodes for x in ele.connectivity])</span>
           <span class="c1"># on stocke sa connectivite</span>
           <span class="n">connec</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">nb_elements</span><span class="o">+</span><span class="n">i</span><span class="p">):</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">nb_elements</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">=</span><span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span>
           <span class="n">connec</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">nb_elements</span><span class="o">+</span><span class="n">i</span><span class="p">):</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">nb_elements</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">+=</span><span class="n">nb_nodes</span>
           <span class="c1"># on incremente l&#39;indice de l&#39;element triangle courant</span>
           <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

     <span class="n">nb_nodes</span><span class="o">+=</span><span class="nb">len</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
     <span class="n">nb_elements</span> <span class="o">+=</span> <span class="n">i</span>

   <span class="c1"># on calcule le volume de l&#39;objet a partir de sa surface</span>
   <span class="n">OG</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">lmgc90</span><span class="o">.</span><span class="n">surface_T3_compute_volume_inertia</span><span class="p">(</span><span class="n">coor</span><span class="p">,</span> <span class="n">connec</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>


   <span class="c1"># on rend a la matrice d&#39;inertie sa forme de matrice 3x3</span>
   <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

   <span class="c1">#print(volume)</span>
   <span class="c1">#print(&#39;OG &#39;,OG)</span>
   <span class="c1">#print(I)</span>

   <span class="c1"># on ajoute son contacteur polyedre a l&#39;avatar</span>
   <span class="n">body</span><span class="o">.</span><span class="n">addContactors</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="s1">&#39;POLYF&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="n">OG</span><span class="p">,</span>
     <span class="n">nb_patch</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">surfacic_meshes</span><span class="p">),</span> <span class="n">patch</span><span class="o">=</span><span class="n">surfacic_meshes</span><span class="p">)</span>

   <span class="c1"># calcul du volume et de l&#39;inertie du corps (a partir du volume et de l&#39;inertie </span>
   <span class="c1"># du polyedre)</span>
   <span class="n">body</span><span class="o">.</span><span class="n">computeRigidProperties</span><span class="p">()</span>

   <span class="c1"># on renvoie le corps genere</span>
   <span class="k">return</span> <span class="n">body</span></div>

<span class="c1"># fonction qui consrtuit le maillage en hexaedres d&#39;un paralepipede rectangle</span>
<div class="viewcode-block" id="buildMeshH8"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.buildMeshH8">[docs]</a><span class="k">def</span> <span class="nf">buildMeshH8</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span><span class="p">,</span> <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">lz</span><span class="p">,</span> <span class="n">nb_elem_x</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">,</span> <span class="n">nb_elem_z</span><span class="p">,</span> <span class="n">surfacic_mesh_type</span><span class="o">=</span><span class="s1">&#39;Q4&#39;</span><span class="p">):</span>
   <span class="sd">&quot;&quot;&quot;buildMeshH8(x0, y0, z0, lx, ly, lz, nb_elem_x, nb_elem_y, nb_elem_z):</span>

<span class="sd">   this function meshes a given box, and returns the generated mesh</span>

<span class="sd">   WARNING: this function automaticaly defines four groups of surfacic elements:</span>
<span class="sd">   &#39;left&#39; (y=y0), &#39;down&#39; (z=z0), &#39;right&#39; (y=y0 + lx), &#39;up&#39; (z=z0 + lz), </span>
<span class="sd">   &#39;front&#39; (x=x0 + lx), &#39;rear&#39; (x=x0)</span>

<span class="sd">   parameters: </span>

<span class="sd">   - (x0, y0, z0) is position of the rear lower left corner of the box</span>
<span class="sd">   - lx: dimension of the rectangle, following the axis Ox</span>
<span class="sd">   - ly: dimension of the rectangle, following the axis Oy</span>
<span class="sd">   - lz: dimension of the rectangle, following the axis Oy</span>
<span class="sd">   - nb_elem_x: number of elements, following the axis Ox</span>
<span class="sd">   - nb_elem_y: number of elements, following the axis Oy</span>
<span class="sd">   - nb_elem_z: number of elements, following the axis Oz</span>

<span class="sd">   optional parameters:</span>

<span class="sd">   - surfacic_mesh_type=&#39;Q4&#39;: sufacic mesh type:</span>

<span class="sd">     * &quot;Q4&quot;: classic surfacic mesh involving Q4</span>
<span class="sd">     * &quot;2T3&quot;: surfacic mesh involving T3, obtained by splitting one Q4 in two T3  </span>
<span class="sd">   &quot;&quot;&quot;</span>
   
   <span class="c1"># fonction qui renvoie le numero d&#39;un noeud a partir du triplet d&#39;indice (i, j, k)</span>
   <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">nb_elem_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">nb_elem_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">nb_elem_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

   <span class="c1"># on clacule la longueur d&#39;un element suivant </span>
   <span class="c1">#    * la direction 0x</span>
   <span class="n">delta_x</span> <span class="o">=</span> <span class="n">lx</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">nb_elem_x</span><span class="p">)</span>
   <span class="c1">#    * la direction 0x</span>
   <span class="n">delta_y</span> <span class="o">=</span> <span class="n">ly</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">nb_elem_y</span><span class="p">)</span>
   <span class="c1">#    * la direction 0x</span>
   <span class="n">delta_z</span> <span class="o">=</span> <span class="n">lz</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">nb_elem_z</span><span class="p">)</span>

   <span class="c1"># on cree un nouveau maillage 3D</span>
   <span class="n">volumic_mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

   <span class="c1"># calcul des coordonnees des noeuds</span>
 
   <span class="c1"># on initialise le numero du noeud courant a 0</span>
   <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="c1"># pour chaque noeud suivant Oz</span>
   <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
      <span class="c1"># pour chaque noeud suivant Oy</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
         <span class="c1"># pour chaque noeud suivant Ox</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># on incremete le numero du noeud courant</span>
            <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># on calcule les coordonnees du noeud courant</span>
            <span class="n">coor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x0</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">delta_x</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">delta_y</span><span class="p">,</span> <span class="n">z0</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">delta_z</span><span class="p">])</span>
            <span class="c1"># on ajoute le noeud courant au maillage</span>
            <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span> <span class="n">node</span><span class="p">(</span> <span class="n">coor</span><span class="o">=</span><span class="n">coor</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="n">num</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1"># calcul des connectivites des elements volumiques</span>

   <span class="c1"># pour chaque element suivant Oz</span>
   <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_z</span><span class="p">):</span>
      <span class="c1"># pour chaque element suivant Oy</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">):</span>
         <span class="c1"># pour chaque element suivant Ox</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_x</span><span class="p">):</span>
            <span class="c1"># on construit la connectivite de l&#39;element courant</span>
            <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span>
                          <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="c1"># on ajoute l&#39;element courant au maillage</span>
            <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1"># calcul des connectivites des elements surfaciques</span>

   <span class="c1">#    * face du dessous (i.e. z=z0)</span>
   <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="c1"># pour chaque element suivant Oy</span>
   <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">):</span>
      <span class="c1"># pour chaque element suivant Ox</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_x</span><span class="p">):</span>
         <span class="c1"># on construit la connectivite de l&#39;element courant</span>
         <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span>
         <span class="c1"># on ajoute l&#39;element courant au maillage</span>
         <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="s1">&#39;down&#39;</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1">#    * face du dessus (i.e. z=z0 + lz)</span>
   <span class="n">k</span> <span class="o">=</span> <span class="n">nb_elem_z</span> <span class="o">-</span> <span class="mi">1</span>
   <span class="c1"># pour chaque element suivant Oy</span>
   <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">):</span>
      <span class="c1"># pour chaque element suivant Ox</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_x</span><span class="p">):</span>
         <span class="c1"># on construit la connectivite de l&#39;element courant</span>
         <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
         <span class="c1"># on ajoute l&#39;element courant au maillage</span>
         <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1">#    * face de gauche (i.e. y=y0)</span>
   <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="c1"># pour chaque element suivant Oz</span>
   <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_z</span><span class="p">):</span>
      <span class="c1"># pour chaque element suivant Ox</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_x</span><span class="p">):</span>
         <span class="c1"># on construit la connectivite de l&#39;element courant</span>
         <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
         <span class="c1"># on ajoute l&#39;element courant au maillage</span>
         <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1">#    * face de droite (i.e. y=y0 + ly)</span>
   <span class="n">j</span> <span class="o">=</span> <span class="n">nb_elem_y</span> <span class="o">-</span> <span class="mi">1</span>
   <span class="c1"># pour chaque element suivant Oz</span>
   <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_z</span><span class="p">):</span>
      <span class="c1"># pour chaque element suivant Ox</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_x</span><span class="p">):</span>
         <span class="c1"># on construit la connectivite de l&#39;element courant</span>
         <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
         <span class="c1"># on ajoute l&#39;element courant au maillage</span>
         <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1">#    * face de derriere (i.e. x=x0)</span>
   <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="c1"># pour chaque element suivant Oz</span>
   <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_z</span><span class="p">):</span>
      <span class="c1"># pour chaque element suivant Oy</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">):</span>
         <span class="c1"># on construit la connectivite de l&#39;element courant</span>
         <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span>
         <span class="c1"># on ajoute l&#39;element courant au maillage</span>
         <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="s1">&#39;rear&#39;</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1">#    * face de devant (i.e. x=x0 + lx)</span>
   <span class="n">i</span> <span class="o">=</span> <span class="n">nb_elem_x</span> <span class="o">-</span> <span class="mi">1</span>
   <span class="c1"># pour chaque element suivant Oz</span>
   <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_z</span><span class="p">):</span>
      <span class="c1"># pour chaque element suivant Oy</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">):</span>
         <span class="c1"># on construit la connectivite de l&#39;element courant</span>
         <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
         <span class="c1"># on ajoute l&#39;element courant au maillage</span>
         <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="s1">&#39;front&#39;</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1"># si l&#39;utilisateur a demande autre chose que le maillage surfacique en Q4 classique</span>
   <span class="k">if</span> <span class="n">surfacic_mesh_type</span> <span class="o">!=</span> <span class="s2">&quot;Q4&quot;</span><span class="p">:</span>
      <span class="c1"># selon le type de maillage surfacique demande</span>
      <span class="k">if</span> <span class="n">surfacic_mesh_type</span> <span class="o">==</span> <span class="s2">&quot;2T3&quot;</span><span class="p">:</span> <span class="c1"># cas du Q4 coupe en deux T3</span>
         <span class="c1"># pour chaque element</span>
         <span class="k">for</span> <span class="n">i_ele</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">volumic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">)):</span>
            <span class="c1"># on recupere l&#39;element courant</span>
            <span class="n">ele</span><span class="o">=</span><span class="n">volumic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">i_ele</span><span class="p">]</span>
            <span class="c1"># si l&#39;element n&#39;est pas un Q4</span>
            <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;Q4xxx&#39;</span><span class="p">:</span>
               <span class="c1"># on passe au suivant</span>
               <span class="k">continue</span>
           
            <span class="c1"># ici, on est sur que l&#39;element courant est un Q4</span>

            <span class="c1"># on recupere la connectivite du Q4 courant</span>
            <span class="n">connectivity_Q4</span><span class="o">=</span><span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span>
            <span class="c1"># on recupere son entite physique</span>
            <span class="n">physicalEntity_Q4</span><span class="o">=</span><span class="n">ele</span><span class="o">.</span><span class="n">physicalEntity</span>
            <span class="c1"># on construit deux T3 pour remplacer le Q4 courant</span>
            <span class="c1">#    * premier element :</span>
            <span class="c1"># on construit la connectivite du premier element</span>
            <span class="n">connectivity_1</span><span class="o">=</span><span class="p">[</span><span class="n">connectivity_Q4</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">connectivity_Q4</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">connectivity_Q4</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
            <span class="c1"># on cree le premier element</span>
            <span class="n">ele_T3_1</span><span class="o">=</span><span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity_1</span><span class="p">,</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="n">physicalEntity_Q4</span><span class="p">)</span>
            <span class="c1">#    * deuxieme element :</span>
            <span class="c1"># on construit la connectivite du deuxieme element</span>
            <span class="n">connectivity_2</span><span class="o">=</span><span class="p">[</span><span class="n">connectivity_Q4</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">connectivity_Q4</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">connectivity_Q4</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="c1"># on cree le deuxieme element</span>
            <span class="n">ele_T3_2</span><span class="o">=</span><span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity_2</span><span class="p">,</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="n">physicalEntity_Q4</span><span class="p">)</span>

            <span class="c1"># on remplace l&#39;element courant par le premier T3</span>
            <span class="n">ele_T3_1</span><span class="o">.</span><span class="n">number</span><span class="o">=</span><span class="n">i_ele</span>
            <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">i_ele</span><span class="p">]</span><span class="o">=</span><span class="n">ele_T3_1</span>
            <span class="c1"># on ajoute le deuxieme T3 a la fin de la liste des elements</span>
            <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span><span class="n">ele_T3_2</span><span class="p">)</span>

      <span class="c1"># cas par defaut</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="c1"># on affiche un message d&#39;erreur</span>
         <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;unknown surfacic mesh type!&quot;</span><span class="p">)</span>

   <span class="c1"># on renvoie le maillage ainsi contruit</span>
   <span class="k">return</span> <span class="n">volumic_mesh</span></div>

<span class="c1"># fonction qui consrtuit le maillage en hexaedres quadratiques d&#39;un paralepipede rectangle</span>
<div class="viewcode-block" id="buildMeshH20"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.buildMeshH20">[docs]</a><span class="k">def</span> <span class="nf">buildMeshH20</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span><span class="p">,</span> <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">lz</span><span class="p">,</span> <span class="n">nb_elem_x</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">,</span> <span class="n">nb_elem_z</span><span class="p">):</span>
   <span class="sd">&quot;&quot;&quot;buildMeshH20(x0, y0, z0, lx, ly, lz, nb_elem_x, nb_elem_y, nb_elem_z):</span>

<span class="sd">   this function meshes a given box, and returns the generated mesh and set Q4 contactors on sides.</span>

<span class="sd">   WARNING: this function automaticaly defines four groups of surfacic elements:</span>
<span class="sd">   &#39;left&#39; (y=y0), &#39;down&#39; (z=z0), &#39;right&#39; (y=y0 + lx), &#39;up&#39; (z=z0 + lz), </span>
<span class="sd">   &#39;front&#39; (x=x0 + lx), &#39;rear&#39; (x=x0)</span>

<span class="sd">   parameters: </span>

<span class="sd">   - (x0, y0, z0) is position of the rear lower left corner of the box</span>
<span class="sd">   - lx: dimension of the rectangle, following the axis Ox</span>
<span class="sd">   - ly: dimension of the rectangle, following the axis Oy</span>
<span class="sd">   - lz: dimension of the rectangle, following the axis Oy</span>
<span class="sd">   - nb_elem_x: number of elements, following the axis Ox</span>
<span class="sd">   - nb_elem_y: number of elements, following the axis Oy</span>
<span class="sd">   - nb_elem_z: number of elements, following the axis Oz</span>

<span class="sd">   &quot;&quot;&quot;</span>
   
   <span class="c1"># fonction qui renvoie le numero d&#39;un noeud a partir du triplet d&#39;indice (i, j, k)</span>
   <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">mix</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">miy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">miz</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

      <span class="k">assert</span> <span class="p">(</span> <span class="n">miz</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span>  <span class="n">miy</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">mix</span><span class="o">==</span><span class="mi">0</span> <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">miz</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
      <span class="k">assert</span> <span class="p">(</span> <span class="p">(</span><span class="n">miy</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">mix</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">miy</span><span class="o">==</span><span class="mi">0</span> <span class="p">)</span>

      <span class="k">return</span>  <span class="n">k</span> <span class="o">*</span> <span class="p">(</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">nb_elem_x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">nb_elem_y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nb_elem_x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nb_elem_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">nb_elem_x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">nb_elem_y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> \
             <span class="o">+</span><span class="n">miz</span><span class="o">*</span><span class="p">(</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">nb_elem_x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">nb_elem_y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nb_elem_x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nb_elem_y</span> <span class="p">)</span> \
             <span class="o">+</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span>  <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">miz</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">nb_elem_x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">nb_elem_x</span><span class="o">+</span><span class="mi">1</span> <span class="p">)</span> <span class="o">+</span> <span class="n">miy</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">nb_elem_x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> \
             <span class="o">+</span><span class="n">i</span> <span class="o">*</span> <span class="p">(</span>  <span class="mi">2</span><span class="o">-</span><span class="n">miy</span><span class="o">-</span><span class="n">miz</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">mix</span>

   <span class="c1"># length to next element along each axis</span>
   <span class="n">delta_x</span> <span class="o">=</span> <span class="n">lx</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">nb_elem_x</span><span class="p">)</span>
   <span class="n">delta_y</span> <span class="o">=</span> <span class="n">ly</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">nb_elem_y</span><span class="p">)</span>
   <span class="n">delta_z</span> <span class="o">=</span> <span class="n">lz</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">nb_elem_z</span><span class="p">)</span>

   <span class="c1"># on cree un nouveau maillage 3D</span>
   <span class="n">volumic_mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

   <span class="c1"># compute nodes coordinates</span>
   <span class="n">ddz</span> <span class="o">=</span> <span class="n">delta_z</span><span class="o">/</span><span class="mf">2.</span>
 
   <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># for node numbering</span>
   <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nb_elem_z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">k</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">#for a layer with 8 nodes per square</span>
         <span class="n">nby</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">nb_elem_y</span>
         <span class="n">ddy</span> <span class="o">=</span> <span class="n">delta_y</span><span class="o">/</span><span class="mf">2.</span>
      <span class="k">else</span><span class="p">:</span> <span class="c1">#for a layer with 4 nodes per square</span>
         <span class="n">nby</span> <span class="o">=</span> <span class="n">nb_elem_y</span>
         <span class="n">ddy</span> <span class="o">=</span> <span class="n">delta_y</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nby</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
         <span class="k">if</span> <span class="n">k</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nbx</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">nb_elem_x</span>
            <span class="n">ddx</span> <span class="o">=</span> <span class="n">delta_x</span><span class="o">/</span><span class="mf">2.</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">nbx</span> <span class="o">=</span> <span class="n">nb_elem_x</span>
            <span class="n">ddx</span> <span class="o">=</span> <span class="n">delta_x</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># on calcule les coordonnees du noeud courant</span>
            <span class="n">coor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x0</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">ddx</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">ddy</span><span class="p">,</span> <span class="n">z0</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ddz</span><span class="p">])</span>
            <span class="c1"># on ajoute le noeud courant au maillage</span>
            <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span> <span class="n">node</span><span class="p">(</span> <span class="n">coor</span><span class="o">=</span><span class="n">coor</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="n">num</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1"># calcul des connectivites des elements volumiques</span>

   <span class="c1"># pour chaque element suivant Oz</span>
   <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_z</span><span class="p">):</span>
      <span class="c1"># pour chaque element suivant Oy</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">):</span>
         <span class="c1"># pour chaque element suivant Ox</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_x</span><span class="p">):</span>
            <span class="c1"># on construit la connectivite de l&#39;element courant</span>
            <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span>      <span class="p">),</span>   <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span>        <span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span>      <span class="p">),</span>   <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span>        <span class="p">),</span>
                          <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span>    <span class="p">),</span>   <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span>      <span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span>    <span class="p">),</span>   <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span>      <span class="p">),</span>
                          <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span>  <span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span>  <span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span>  <span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span>  <span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span>  <span class="p">,</span> <span class="n">k</span>  <span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
                          <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span>  <span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span>  <span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
                          <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span>  <span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span>  <span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span>  <span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span>  <span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                         <span class="p">]</span>
            <span class="c1"># on ajoute l&#39;element courant au maillage</span>
            <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1"># copy past from above...</span>

   <span class="c1"># surfacic elements</span>
   <span class="c1"># down (i.e. z=z0)</span>
   <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_x</span><span class="p">):</span>
         <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> 
                       <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
         <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="s1">&#39;down&#39;</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1"># up (i.e. z=z0 + lz)</span>
   <span class="n">k</span> <span class="o">=</span> <span class="n">nb_elem_z</span> <span class="o">-</span> <span class="mi">1</span>
   <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_x</span><span class="p">):</span>
         <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                       <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
         <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1"># left (i.e. y=y0)</span>
   <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_z</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_x</span><span class="p">):</span>
         <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                       <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
         <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1"># right (i.e. y=y0 + ly)</span>
   <span class="n">j</span> <span class="o">=</span> <span class="n">nb_elem_y</span> <span class="o">-</span> <span class="mi">1</span>
   <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_z</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_x</span><span class="p">):</span>
         <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                       <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
         <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1"># rear (i.e. x=x0)</span>
   <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_z</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">):</span>
         <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">),</span>
                       <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
         <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="s1">&#39;rear&#39;</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1"># front (i.e. x=x0 + lx)</span>
   <span class="n">i</span> <span class="o">=</span> <span class="n">nb_elem_x</span> <span class="o">-</span> <span class="mi">1</span>
   <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_z</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">):</span>
         <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> 
                       <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
         <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="s1">&#39;front&#39;</span><span class="p">)</span> <span class="p">)</span>

   <span class="k">return</span> <span class="n">volumic_mesh</span></div>
   <span class="c1">##new_mesh = mesh(3)</span>
   <span class="c1">### first build Q8 mesh</span>
   <span class="c1">##m2 = buildMesh2D(&#39;Q8&#39;, x0, y0, lx, ly, nb_elem_x, nb_elem_y)</span>
   <span class="c1">### second extrude on all the layers</span>
   <span class="c1">##nb_nodes = len(m2.nodes)</span>
   <span class="c1">##for nb_z in range(nb_elem_z):</span>
   <span class="c1">##  # new intermediate nodes</span>
   <span class="c1">##  for n in m2.nodes[::2]:</span>
   <span class="c1">##    new_coor = np.array([n.coor[0],n.coor[1],z0+nb_z*lz/(2*nb_elem_z)])</span>
   <span class="c1">##    new_mesh.addNode(node(coor=new_coor,number=l*nb_nodes+n.number))</span>
   <span class="c1">##  # new layer</span>
   <span class="c1">##  for n in m2.nodes:</span>
   <span class="c1">##    new_coor = np.array([n.coor[0],n.coor[1],z0+nb_z*lz/nb_elem_z])</span>
   <span class="c1">##    new_mesh.addNode(node(coor=new_coor,number=l*nb_nodes+n.number))</span>

<span class="c1"># fonction qui prend un maillage 3D et l&#39;eclate en rigides (polygones)</span>
<div class="viewcode-block" id="rigidsFromMesh3D"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.rigidsFromMesh3D">[docs]</a><span class="k">def</span> <span class="nf">rigidsFromMesh3D</span><span class="p">(</span><span class="n">volumic_mesh</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;BLUEx&#39;</span><span class="p">):</span>
   <span class="sd">&quot;&quot;&quot;rigidsFromMesh3D(volumic_mesh, model, material, color=&#39;BLUEx&#39;):</span>

<span class="sd">   this function build a set of rigids from a 3D mesh, each rigid</span>
<span class="sd">   is a polygon made from an element of the given mesh</span>

<span class="sd">   parameters:</span>

<span class="sd">   - volumic_mesh: a 3D mesh</span>
<span class="sd">   - model: a given model</span>
<span class="sd">   - material: a given material</span>

<span class="sd">   optional parameter:</span>

<span class="sd">   - color=&#39;BLUEx&#39;: color of the polygon contactors</span>
<span class="sd">   &quot;&quot;&quot;</span>

   <span class="c1"># on verifie que l&#39;utilisateur a bien donne un maillage</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">volumic_mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
      <span class="c1"># si ce n&#39;est pas le cas, on affiche un message d&#39;erreur</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given volumic mesh is not a mesh!&quot;</span><span class="p">)</span>

   <span class="c1"># on verifie que le maillage est bien 3D</span>
   <span class="k">if</span> <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
      <span class="c1"># si ce n&#39;est pas le cas, on affiche un message d&#39;erreur</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given mesh is not a volumic mesh&quot;</span><span class="p">)</span>

   <span class="c1"># on declare un container d&#39;avatars pour stocker les rigides</span>
   <span class="n">bodies</span><span class="o">=</span><span class="n">avatars</span><span class="p">()</span>

   <span class="c1"># pour chaque element du maillage</span>
   <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si l&#39;element n&#39;est pas un volume simple</span>
      <span class="k">if</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;TE4xx&#39;</span><span class="p">,</span> <span class="s1">&#39;PRI6x&#39;</span><span class="p">,</span> <span class="s1">&#39;H8xxx&#39;</span><span class="p">]:</span>
         <span class="c1"># on passe au suivant</span>
         <span class="k">continue</span>

      <span class="n">vertices</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
          <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">volumic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">coor</span> <span class="p">)</span>
      <span class="n">body</span> <span class="o">=</span> <span class="n">rigidPolyhedron</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">generation_type</span><span class="o">=</span><span class="s1">&#39;vertices&#39;</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>

      <span class="c1"># on ajoute le corps rigide a la liste des corps</span>
      <span class="n">bodies</span><span class="o">.</span><span class="n">addAvatar</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>

   <span class="c1"># on renvoie la liste des corps generee</span>
   <span class="k">return</span> <span class="n">bodies</span></div>

<span class="c1"># Fonction qui oriente la face(i,j,k) d un element TE4xx </span>
<span class="k">def</span> <span class="nf">oriente_surf</span><span class="p">(</span><span class="n">body</span><span class="p">,</span><span class="n">ele</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span><span class="o">==</span><span class="s1">&#39;TE4xx&#39;</span><span class="p">:</span>
        <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;This function is designed for TE4xx elements&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">):</span>
        <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;The face (i,j,k) does not belong to ele&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">i</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">m</span>
            <span class="k">break</span>

    <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">ic</span><span class="p">]:</span>
            <span class="k">break</span>

    <span class="n">ni</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">nj</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">nk</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="n">nl</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

    <span class="n">v1</span> <span class="o">=</span> <span class="n">nj</span><span class="o">.</span><span class="n">coor</span> <span class="o">-</span> <span class="n">ni</span><span class="o">.</span><span class="n">coor</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">coor</span> <span class="o">-</span> <span class="n">ni</span><span class="o">.</span><span class="n">coor</span>
    <span class="n">v3</span> <span class="o">=</span> <span class="n">nl</span><span class="o">.</span><span class="n">coor</span> <span class="o">-</span> <span class="n">ni</span><span class="o">.</span><span class="n">coor</span>
    <span class="n">v4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span><span class="n">v4</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">connec0</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,(</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">connec0</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,(</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">connec0</span>

<span class="c1"># fonction qui eclate un objet maille</span>
<div class="viewcode-block" id="explodeMeshedAvatar3D"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.explodeMeshedAvatar3D">[docs]</a><span class="k">def</span> <span class="nf">explodeMeshedAvatar3D</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;BLEUx&#39;</span><span class="p">,</span> <span class="n">quadrature</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
   <span class="sd">&#39;&#39;&#39;bodies=explodeMeshedAvatar3D(body, color=&#39;BLEUx&#39;, w=None):</span>
<span class="sd">        </span>
<span class="sd">   this function &quot;explodes&quot; a given 3D meshed avatar, i.e. gets a meshed avatar and returns a</span>
<span class="sd">   list of bodies, where each body is a cell of the given meshed avatar. Each new body</span>
<span class="sd">   have a list of contactor inherited from the connectivity of the given meshed avatar.</span>
<span class="sd">   </span>
<span class="sd">   parameters:</span>
<span class="sd">        </span>
<span class="sd">   - body: a 3D meshed avatar</span>
<span class="sd">   </span>
<span class="sd">   optional parameters:</span>
<span class="sd">   </span>
<span class="sd">   - color: default color of the contactors</span>
<span class="sd">   - quadrature : quadrature option for contactors</span>
<span class="sd">   - color_dict: a dictionnary associating a color to the physical entity of the element</span>
<span class="sd">   &#39;&#39;&#39;</span>
   
   <span class="c1"># on verifie que l&#39;objet est bien un maillage :</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">avatar</span><span class="p">):</span>
      <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;this object is not a body!&#39;</span><span class="p">)</span>
   <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">atype</span> <span class="o">!=</span> <span class="s1">&#39;MAILx&#39;</span><span class="p">:</span>
      <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;this body is not a MAILx!&#39;</span><span class="p">)</span>
                            
   <span class="c1"># on verifie sa dimension</span>
   <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
      <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;this is function is designed for 3D bodies!&#39;</span><span class="p">)</span>
                                    
   <span class="c1"># on verifie que l&#39;objet soit maille avec des elements d&#39;ordre 1</span>
   <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;TE4xx&#39;</span> <span class="ow">and</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;T3xxx&#39;</span><span class="p">:</span>
         <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;this function is designed for TE4xx elements!&#39;</span><span class="p">)</span>
                                                
   <span class="c1"># on definit une liste d&#39;avatar, qui va contenir la liste des elements</span>
   <span class="c1"># devenus corps independants</span>
   <span class="n">bodies</span> <span class="o">=</span> <span class="n">avatars</span><span class="p">()</span>
   
   <span class="c1"># on definit :</span>
   <span class="c1">#   *  la table qui associe un numero d&#39;element du maillage a l&#39;indice du nouveau corps</span>
   <span class="c1">#      qui lui correspond</span>
   <span class="n">ele2bodyIndex</span><span class="o">=</span><span class="p">{}</span>
   <span class="c1">#   *  la table qui associe un numero d&#39;element d&#39;un nouveau corps au numero d&#39;element du maillage</span>
   <span class="c1">#      qui lui correspond</span>
   <span class="n">body2eleIndex</span><span class="o">=</span><span class="p">{}</span>
                                                        
   <span class="k">if</span> <span class="ow">not</span> <span class="n">color_dict</span><span class="p">:</span>
      <span class="n">color_dict</span> <span class="o">=</span> <span class="p">{}</span>
          
   <span class="c1"># on cree un corps pour chaque element fini</span>
                                                                
   <span class="n">bodyIndex</span><span class="o">=</span><span class="mi">0</span>
   <span class="c1"># pour chaque element fini</span>
   <span class="k">for</span> <span class="n">nbe</span><span class="p">,</span><span class="n">ele</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">):</span>
      <span class="c1"># si l&#39;element n&#39;est pas un element de volume</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
         <span class="c1"># on saute l&#39;element</span>
         <span class="k">continue</span>
      <span class="c1"># on ajoute le nouveau corps dans la table qui associe un numero d&#39;element du maillage</span>
      <span class="c1"># a l&#39;indice du nouveau corps</span>
      <span class="n">ele2bodyIndex</span><span class="p">[</span><span class="n">ele</span><span class="o">.</span><span class="n">number</span><span class="p">]</span><span class="o">=</span><span class="n">bodyIndex</span>
      <span class="c1"># et dans la table qui associe l&#39;indice du nouveau corps au numero d&#39;element du maillage</span>
      <span class="n">body2eleIndex</span><span class="p">[</span><span class="n">bodyIndex</span><span class="p">]</span><span class="o">=</span><span class="n">ele</span><span class="o">.</span><span class="n">number</span>
                                                                                    
      <span class="n">bodyIndex</span> <span class="o">+=</span> <span class="mi">1</span>
                                                                                        
      <span class="c1"># on cree un nouveau corps maille 3D</span>
      <span class="n">new_body</span> <span class="o">=</span> <span class="n">avatar</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
      <span class="c1"># on ajoute au nouveau corps un nouvel element fini, du meme type que</span>
      <span class="c1"># l&#39;element courant mais dont la connectivite est triviale</span>
      <span class="c1"># N.B.: on conserve la physical entity, i.e. le groupe de l&#39;element</span>
      <span class="n">new_body</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="n">geoElement2dimension</span><span class="p">[</span><span class="n">ele</span><span class="o">.</span><span class="n">etype</span><span class="p">],</span>
                                <span class="n">connectivity</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                                <span class="n">physicalEntity</span><span class="o">=</span><span class="n">ele</span><span class="o">.</span><span class="n">physicalEntity</span><span class="p">)</span> <span class="p">)</span>
                                                                                            
      <span class="c1"># on ajoute au corps les seuls noeuds dont il a besoin</span>
      
      <span class="c1"># on initialise le nombre de noeuds du nouvel element a 0</span>
      <span class="n">nbNodes</span><span class="o">=</span><span class="mi">0</span>
      <span class="c1"># pour chaque noeud de l&#39;element courant</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
         <span class="c1"># on incremente le nombre de noeuds du nouvel element</span>
         <span class="n">nbNodes</span> <span class="o">+=</span> <span class="mi">1</span>
         <span class="c1"># on recupere l&#39;objet node associe</span>
         <span class="n">n</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
         <span class="c1"># on peut alors construire le nouveau noeud, connaissant ses</span>
         <span class="c1"># coordonnees</span>
         <span class="n">new_body</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span> <span class="n">node</span><span class="p">(</span> <span class="n">coor</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="n">coor</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="n">nbNodes</span><span class="p">)</span> <span class="p">)</span>
      
      <span class="c1"># on ajoute le corps genere au container</span>
      <span class="n">bodies</span> <span class="o">+=</span> <span class="n">new_body</span>

   <span class="c1"># on definit un container pour stocker les listes d&#39;adjacence de chaque</span>
   <span class="c1"># noeud</span>
   <span class="n">l_node2ele</span> <span class="o">=</span> <span class="p">[]</span>
                                                                                                                
   <span class="c1"># pour chaque noeud du corps, on initialise une liste d&#39;adjacence vide</span>
   <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
      <span class="n">l_node2ele</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                                                                                                                            
   <span class="c1"># pour chaque element du maillage</span>
   <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si l&#39;element n&#39;est pas un element de volume</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
         <span class="c1"># on saute l&#39;element</span>
         <span class="k">continue</span>
      <span class="c1"># pour chaque noeud de l&#39;element</span>
      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
         <span class="c1"># on ajoute l&#39;element courant dans la liste d&#39;adjacence du noeud</span>
         <span class="c1"># courant</span>
         <span class="n">l_node2ele</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span>
   <span class="c1"># ici, la liste d&#39;adjacence de chaque noeud est remplie</span>
                                                                                                                                                
   <span class="c1"># on s&#39;en sert par la suite pour placer des contacteurs sur les elements de</span>
   <span class="c1"># la surface libre</span>

   <span class="c1"># pour chaque element</span>
   <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>

       <span class="c1"># si l&#39;element n&#39;est pas un element de volume</span>
       <span class="k">if</span> <span class="ow">not</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
          <span class="c1"># on saute l&#39;element</span>
          <span class="k">continue</span>
   
       <span class="c1"># pour chaque noeud de l&#39;element</span>
       <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
          <span class="c1"># On recupere le numero du noeud</span>
          <span class="n">i</span> <span class="o">=</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span>
          <span class="c1"># et les deux noeuds suivants, dans la table de connectivite de</span>
          <span class="c1"># l&#39;element</span>
          <span class="n">j</span> <span class="o">=</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span><span class="p">]</span>
          <span class="n">k</span> <span class="o">=</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span><span class="p">]</span>
          <span class="c1"># (i,j,k) definit une face de l&#39;element courant</span>
          
          <span class="c1"># on cherche maintenant l&#39;element adjacent a l&#39;element courant par</span>
          <span class="c1"># cette face</span>
          
          <span class="c1"># on indique qu&#39;on ne l&#39;a pas encore trouve</span>
          <span class="n">is_found</span> <span class="o">=</span> <span class="mi">0</span>
          <span class="n">found_ele</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="c1"># pour chaque element adjacent au noeud i</span>
          <span class="k">for</span> <span class="n">adj_ele</span> <span class="ow">in</span> <span class="n">l_node2ele</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
             <span class="c1"># si on a trouve un element adjacent a la face (i, j, k)</span>
             <span class="k">if</span> <span class="n">is_found</span><span class="p">:</span>
                <span class="c1"># on sort de la boucle</span>
                <span class="k">break</span>
             <span class="c1"># si c&#39;est l&#39;element courant</span>
             <span class="k">if</span> <span class="n">ele</span> <span class="o">==</span> <span class="n">adj_ele</span><span class="p">:</span>
                <span class="c1"># on passe au suivant</span>
                <span class="k">continue</span>
             <span class="c1"># pour chaque noeud de l&#39;element adjacent courant</span>
             <span class="n">comp0</span> <span class="o">=</span> <span class="mi">0</span>
             <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">adj_ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                 <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                    <span class="n">comp0</span> <span class="o">+=</span> <span class="mi">1</span>
                 <span class="k">if</span> <span class="n">comp0</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># on a trouve l&#39;element adjacent a l&#39;element courant, par</span>
                    <span class="c1"># la face (i, j, k)</span>
                    <span class="n">is_found</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">found_ele</span> <span class="o">=</span> <span class="n">adj_ele</span>
                    <span class="c1"># on sort de la boucle</span>
                    <span class="k">break</span>
          
          <span class="c1"># si on a trouve l&#39;element adjacent a l&#39;element courant par</span>
          <span class="c1"># la face (i, j, k)</span>
          <span class="k">if</span> <span class="n">is_found</span><span class="p">:</span>
             <span class="c1"># la face (i, j, k) est dans le volume, et doit porter des</span>
             <span class="c1"># contacteur candidat et antagoniste en vis-a-vis</span>

             <span class="c1"># on recupere le nouveau corps associe a l&#39;element courant</span>
             <span class="n">new_body</span> <span class="o">=</span> <span class="n">bodies</span><span class="p">[</span><span class="n">ele2bodyIndex</span><span class="p">[</span><span class="n">ele</span><span class="o">.</span><span class="n">number</span><span class="p">]]</span>
             <span class="c1"># on construit l&#39;element qui supporte le contacteur : un triangle</span>
             <span class="c1"># a trois noeuds</span>
             <span class="n">connec0</span> <span class="o">=</span> <span class="n">oriente_surf</span><span class="p">(</span><span class="n">body</span><span class="p">,</span><span class="n">ele</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
             <span class="n">surf</span> <span class="o">=</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connec0</span><span class="p">)</span>
             <span class="c1"># on positionne un contacteur sur l&#39;element courant, en fonction</span>
             <span class="c1"># de son numero</span>
             <span class="k">try</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">color_dict</span><span class="p">[</span><span class="n">ele</span><span class="o">.</span><span class="n">physicalEntity</span><span class="p">]</span>
             <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">color</span>
                
             <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">number</span> <span class="o">&gt;</span> <span class="n">found_ele</span><span class="o">.</span><span class="n">number</span><span class="p">:</span>
                <span class="c1"># si son numero est plus grand que celui de l&#39;element adjacent</span>
                <span class="c1"># il porte des noeuds candidats</span>
                <span class="c1"># on cree un contacteur candidat</span>
                <span class="n">cd</span> <span class="o">=</span> <span class="n">contactorFactory</span><span class="p">(</span><span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="s1">&#39;CSpxx&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">col</span><span class="p">,</span> <span class="n">quadrature</span> <span class="o">=</span> <span class="n">quadrature</span><span class="p">)</span>
                <span class="c1"># on l&#39;ajoute au nouveau corps correspondant a l&#39;element</span>
                <span class="c1"># courant</span>
                <span class="c1"># N.B.: on utilise ici une methode privee de la classe avatar</span>
                <span class="c1">#       a dessin! Cette methode est declaree privee pour qu&#39;elle</span>
                <span class="c1">#       ne soit pas utilisee dans les scripts utilisateurs. Ici,</span>
                <span class="c1">#       on sait ce qu&#39;on fait en ajoutant un contacteur a la main!</span>
                <span class="n">new_body</span><span class="o">.</span><span class="n">_addContactor</span><span class="p">(</span><span class="n">cd</span><span class="p">)</span>
                
             <span class="k">else</span><span class="p">:</span>
                <span class="c1"># sinon, il porte une surface antagoniste</span>
                
                <span class="c1"># on cree un contacteur antagoniste</span>
                <span class="n">an</span> <span class="o">=</span> <span class="n">contactorFactory</span><span class="p">(</span><span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="s1">&#39;ASpxx&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">col</span><span class="p">)</span>
                <span class="c1"># on l&#39;ajoute au nouveau corps correspondant a l&#39;element</span>
                <span class="c1"># courant</span>
                <span class="c1"># N.B.: on utilise ici une methode privee de la classe avatar</span>
                <span class="c1">#       a dessin! Cette methode est declaree privee pour qu&#39;elle</span>
                <span class="c1">#       ne soit pas utilisee dans les scripts utilisateurs. Ici,</span>
                <span class="c1">#       on sait ce qu&#39;on fait en ajoutant un contacteur a la main!</span>
                <span class="n">new_body</span><span class="o">.</span><span class="n">_addContactor</span><span class="p">(</span><span class="n">an</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
             <span class="c1"># sinon, le triangle appartient a la surface libre et on doit recuperer</span>
             <span class="c1"># l&#39;element surface associe, s&#39;il existe</span>
                      
             <span class="c1"># on recupere le nouveau corps associe a l&#39;element courant</span>
             <span class="n">new_body</span> <span class="o">=</span> <span class="n">bodies</span><span class="p">[</span><span class="n">ele2bodyIndex</span><span class="p">[</span><span class="n">ele</span><span class="o">.</span><span class="n">number</span><span class="p">]]</span>
             <span class="c1"># on definit un objet pour recevoir l&#39;element surface associe</span>
             <span class="n">found_surf</span> <span class="o">=</span> <span class="kc">None</span>
             <span class="c1"># pour chaque element</span>
             <span class="k">for</span> <span class="n">ele_surf</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
                <span class="c1"># si l&#39;element n&#39;est pas un triangle</span>
                <span class="k">if</span> <span class="n">ele_surf</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;T3xxx&#39;</span><span class="p">:</span>
                   <span class="c1"># on passe au suivant</span>
                   <span class="k">continue</span>
                   <span class="c1"># si la connectivite correspond</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">ele_surf</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ele_surf</span><span class="o">.</span><span class="n">connectivity</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ele_surf</span><span class="o">.</span><span class="n">connectivity</span><span class="p">):</span>
                   <span class="c1"># on a trouve l&#39;element surface</span>
                   <span class="n">found_surf</span> <span class="o">=</span> <span class="n">ele_surf</span>
                   <span class="c1"># on sort de la boucle</span>
                   <span class="k">break</span>
                      
             <span class="c1"># si l&#39;element surface associe existe</span>
             <span class="k">if</span> <span class="n">found_surf</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># on cree l&#39;element surface a ajouter au corps</span>
                <span class="n">connec0</span> <span class="o">=</span> <span class="n">oriente_surf</span><span class="p">(</span><span class="n">body</span><span class="p">,</span><span class="n">ele</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
                <span class="n">surf</span> <span class="o">=</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connec0</span><span class="p">,</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="n">found_surf</span><span class="o">.</span><span class="n">physicalEntity</span><span class="p">)</span>
                    
                <span class="c1"># on l&#39;ajoute au nouveau corps</span>
                <span class="n">new_body</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span><span class="n">surf</span><span class="p">)</span>
                         
   <span class="c1"># on enumere les nouveau avatars</span>
   <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">new_body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
      <span class="c1"># on definit la liste des groupes du nouveau corps</span>
      <span class="n">new_body</span><span class="o">.</span><span class="n">defineGroups</span><span class="p">()</span>
      <span class="c1"># on recupere l&#39;element de l&#39;avatar continu, auquel est associe le</span>
      <span class="c1"># nouveau corps courant</span>
      <span class="n">bulk</span><span class="o">=</span><span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">body2eleIndex</span><span class="p">[</span><span class="n">num</span><span class="p">]]</span>
      <span class="c1"># on attribue au nouveau corps le modele de l&#39;element de l&#39;avatar</span>
      <span class="c1"># continu qui lui associe</span>
      <span class="n">new_body</span><span class="o">.</span><span class="n">defineModel</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
      <span class="c1"># on attribue au nouveau corps le materiau de l&#39;element de l&#39;avatar</span>
      <span class="c1"># continu qui lui associe</span>
      <span class="n">new_body</span><span class="o">.</span><span class="n">defineMaterial</span><span class="p">(</span><span class="n">material</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">material</span><span class="p">)</span>
   <span class="c1"># on renvoie le container de corps genere</span>
   <span class="k">return</span> <span class="n">bodies</span></div>



</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pylmgc90 2025.rc1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pylmgc90.pre.build_avatar.mesh3D</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2025, CNRS, UM.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>