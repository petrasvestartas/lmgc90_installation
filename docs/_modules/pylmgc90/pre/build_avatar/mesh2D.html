
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pylmgc90.pre.build_avatar.mesh2D &#8212; pylmgc90 2025.rc1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinxdoc.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pylmgc90 2025.rc1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pylmgc90.pre.build_avatar.mesh2D</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pylmgc90.pre.build_avatar.mesh2D</h1><div class="highlight"><pre>
<span></span><span class="c1"># module qui fournit des macros pour construire et/ou manipuler des maillages 2D</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">from</span> <span class="nn">..avatar.avatar</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">..avatar.bulk.element</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">..avatar.contactor.contactor</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">..avatar.group.group</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">..avatars</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">.mesh</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">..utilities.error</span>    <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># import du module permettant de savoir si on pourra importer les pre_tools</span>
<span class="kn">from</span> <span class="nn">..utilities.check_compiled_modules</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">..avatar.contactor.contactorFactory</span> <span class="kn">import</span> <span class="n">contactorFactory</span>

<span class="c1"># si on peut essayer d&#39;importer le module pre_tools sans tout faire planter</span>
<span class="k">if</span> <span class="n">import_lmgc90</span><span class="p">():</span>
   <span class="c1"># on essaye</span>
   <span class="k">try</span><span class="p">:</span>
      <span class="kn">from</span> <span class="nn">...chipy</span> <span class="kn">import</span> <span class="n">lmgc90</span>
   <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unable to import wrapped part of the 2D mesh generator module!&#39;</span><span class="p">)</span>
      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;You must build 2D meshes using an external tool&#39;</span><span class="p">)</span>
   <span class="k">except</span><span class="p">:</span>
      <span class="k">raise</span>

<span class="c1"># fonction qui construit un corps deformable a partir en maillant un rectangle :</span>
<span class="c1">#   - mesh_type : type de maillage :</span>
<span class="c1">#        - &#39;Q4&#39; : maillage en Q4</span>
<span class="c1">#        - &#39;2T3&#39; : maillage en T3, obtenus en coupant en deux des Q4</span>
<span class="c1">#        - &#39;4T3&#39; : maillage en T3, obtenus en coupant en quatre des Q4</span>
<span class="c1">#        - &#39;Q8&#39; : maillage en Q8</span>
<span class="c1">#   - (x0, y0) : position du coin inferieur gauche du recatngle</span>
<span class="c1">#   - lx : dimension du rectangle, suivant l&#39;axe x</span>
<span class="c1">#   - ly : dimension du rectangle, suivant l&#39;axe y</span>
<span class="c1">#   - nb_elem_x : nombre d&#39;elements, suivant l&#39;axe x</span>
<span class="c1">#   - nb_elem_y: nombre d&#39;elements, suivant l&#39;axe y</span>
<span class="c1">#   - material : materiau</span>
<span class="c1">#   - model : modele</span>
<span class="c1">#   - number : numero du corps</span>
<div class="viewcode-block" id="buildMesh2D"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.buildMesh2D">[docs]</a><span class="k">def</span> <span class="nf">buildMesh2D</span><span class="p">(</span><span class="n">mesh_type</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">nb_elem_x</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
   <span class="sd">&#39;&#39;&#39;buildMesh2D=buildMesh2D(mesh_type, x0, y0, lx, ly, nb_elem_x, nb_elem_y, vertices=None, number=None):</span>

<span class="sd">   this function meshes a given rectangle, and returns the generated mesh</span>

<span class="sd">   WARNING: this function automaticaly defines four groups of surfacic elements:</span>
<span class="sd">   &#39;left&#39;, &#39;down&#39;, &#39;right&#39;, &#39;up&#39;</span>

<span class="sd">   parameters: </span>

<span class="sd">   - mesh_type: type of mesh:</span>

<span class="sd">     - &#39;Q4&#39;: mesh with elements Q4</span>
<span class="sd">     - &#39;2T3&#39;: mesh with elements T3, obtained by spitting one Q4 in two T3</span>
<span class="sd">     - &#39;4T3&#39;: mesh with elements T3, obtained by spitting one Q4 in four T3 </span>
<span class="sd">     - &#39;Q8&#39;: mesh with elements Q8</span>

<span class="sd">   - (x, y) is position of the lower left corner of the rectangle </span>
<span class="sd">   - lx: dimension of the rectangle, following the axis Ox</span>
<span class="sd">   - ly: dimension of the rectangle, following the axis Oy</span>
<span class="sd">   - nb_elem_x: number of elements, following the axis Ox</span>
<span class="sd">   - nb_elem_y: number of elements, following the axis Oy</span>

<span class="sd">   optional parameters:</span>

<span class="sd">   - vertices=None: a given list of x,y-coordinates, following a suitable Q4-mesh node ordering</span>
<span class="sd">   - number=None: index of the avatar (still present to ensure compatibility)&#39;&#39;&#39;</span>
   <span class="c1"># test de coherence</span>

   <span class="c1"># si on donne une liste de sommets</span>
   <span class="k">if</span> <span class="p">(</span> <span class="n">vertices</span> <span class="p">):</span>
      <span class="c1"># le maillage doit etre en Q4, partir du point (0, 0), et verifier</span>
      <span class="c1"># lx = nb_elem_x et ly = nb_elem_y</span>
      <span class="k">if</span> <span class="n">mesh_type</span> <span class="o">!=</span> <span class="s1">&#39;Q4&#39;</span><span class="p">:</span>
         <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;only a Q4 mesh accepts a list of vertices!&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">x0</span> <span class="o">!=</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">y0</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
         <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;when list of vertices is given, (x0, y0) must be (0., 0.)!&#39;</span> <span class="p">)</span>
      <span class="k">if</span> <span class="n">lx</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="n">nb_elem_x</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ly</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="n">nb_elem_y</span><span class="p">):</span>
         <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;when list of vertices is given, (lx, ly) must be (float(nb_elem_x), float(nb_elem_y))!&#39;</span><span class="p">)</span>

   <span class="c1"># calcul du maillage, selon son type :</span>

   <span class="k">if</span> <span class="n">mesh_type</span> <span class="o">==</span> <span class="s1">&#39;Q4&#39;</span><span class="p">:</span> <span class="c1"># cas du maillage en Q4 </span>
      <span class="c1"># dimensionnement des vecteurs pour stocker le maillage</span>
      <span class="p">[</span><span class="n">size_nodes</span><span class="p">,</span> <span class="n">size_nb_node_per_ele_vol</span><span class="p">,</span> <span class="n">size_conn_vol</span><span class="p">]</span><span class="o">=</span><span class="n">lmgc90</span><span class="o">.</span><span class="n">mesh2D_SizeMeshQ4</span><span class="p">(</span><span class="n">nb_elem_x</span><span class="p">,</span> 
         <span class="n">nb_elem_y</span><span class="p">)</span>
      <span class="c1"># calcul du maillage</span>
      <span class="p">[</span><span class="n">nodes</span><span class="p">,</span> <span class="n">nb_node_per_ele_vol</span><span class="p">,</span> <span class="n">conn_vol</span><span class="p">]</span><span class="o">=</span><span class="n">lmgc90</span><span class="o">.</span><span class="n">mesh2D_MeshQ4</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> 
         <span class="n">nb_elem_x</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">,</span> <span class="n">size_nodes</span><span class="p">,</span> <span class="n">size_nb_node_per_ele_vol</span><span class="p">,</span> 
         <span class="n">size_conn_vol</span><span class="p">)</span>
   <span class="k">elif</span> <span class="n">mesh_type</span> <span class="o">==</span> <span class="s1">&#39;2T3&#39;</span><span class="p">:</span> <span class="c1"># cas du maillage en T3, obtenus en coupant en deux </span>
      <span class="c1"># des Q4</span>
      <span class="p">[</span><span class="n">size_nodes</span><span class="p">,</span> <span class="n">size_nb_node_per_ele_vol</span><span class="p">,</span> <span class="n">size_conn_vol</span><span class="p">]</span><span class="o">=</span><span class="n">lmgc90</span><span class="o">.</span><span class="n">mesh2D_SizeMesh2T3</span><span class="p">(</span><span class="n">nb_elem_x</span><span class="p">,</span> 
         <span class="n">nb_elem_y</span><span class="p">)</span>
      <span class="c1"># calcul du maillage</span>
      <span class="p">[</span><span class="n">nodes</span><span class="p">,</span> <span class="n">nb_node_per_ele_vol</span><span class="p">,</span> <span class="n">conn_vol</span><span class="p">]</span><span class="o">=</span><span class="n">lmgc90</span><span class="o">.</span><span class="n">mesh2D_Mesh2T3</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> 
         <span class="n">nb_elem_x</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">,</span> <span class="n">size_nodes</span><span class="p">,</span> <span class="n">size_nb_node_per_ele_vol</span><span class="p">,</span> 
         <span class="n">size_conn_vol</span><span class="p">)</span>
   <span class="k">elif</span> <span class="n">mesh_type</span> <span class="o">==</span> <span class="s1">&#39;4T3&#39;</span><span class="p">:</span> <span class="c1"># cas du maillage en T3, obtenus en coupant en </span>
      <span class="c1"># quatre des Q4</span>
      <span class="p">[</span><span class="n">size_nodes</span><span class="p">,</span> <span class="n">size_nb_node_per_ele_vol</span><span class="p">,</span> <span class="n">size_conn_vol</span><span class="p">]</span><span class="o">=</span><span class="n">lmgc90</span><span class="o">.</span><span class="n">mesh2D_SizeMesh4T3</span><span class="p">(</span><span class="n">nb_elem_x</span><span class="p">,</span> 
         <span class="n">nb_elem_y</span><span class="p">)</span>
      <span class="c1"># calcul du maillage</span>
      <span class="p">[</span><span class="n">nodes</span><span class="p">,</span> <span class="n">nb_node_per_ele_vol</span><span class="p">,</span> <span class="n">conn_vol</span><span class="p">]</span><span class="o">=</span><span class="n">lmgc90</span><span class="o">.</span><span class="n">mesh2D_Mesh4T3</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> 
         <span class="n">nb_elem_x</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">,</span> <span class="n">size_nodes</span><span class="p">,</span> <span class="n">size_nb_node_per_ele_vol</span><span class="p">,</span> 
         <span class="n">size_conn_vol</span><span class="p">)</span>
   <span class="k">elif</span> <span class="n">mesh_type</span> <span class="o">==</span> <span class="s1">&#39;Q8&#39;</span><span class="p">:</span> <span class="c1"># cas du maillage en Q8 </span>
      <span class="c1"># dimensionnement des vecteurs pour stocker le maillage</span>
      <span class="p">[</span><span class="n">size_nodes</span><span class="p">,</span> <span class="n">size_nb_node_per_ele_vol</span><span class="p">,</span> <span class="n">size_conn_vol</span><span class="p">]</span><span class="o">=</span><span class="n">lmgc90</span><span class="o">.</span><span class="n">mesh2D_SizeMeshQ8</span><span class="p">(</span><span class="n">nb_elem_x</span><span class="p">,</span> 
         <span class="n">nb_elem_y</span><span class="p">)</span>
      <span class="c1"># calcul du maillage</span>
      <span class="p">[</span><span class="n">nodes</span><span class="p">,</span> <span class="n">nb_node_per_ele_vol</span><span class="p">,</span> <span class="n">conn_vol</span><span class="p">]</span><span class="o">=</span><span class="n">lmgc90</span><span class="o">.</span><span class="n">mesh2D_MeshQ8</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> 
         <span class="n">nb_elem_x</span><span class="p">,</span> <span class="n">nb_elem_y</span><span class="p">,</span> <span class="n">size_nodes</span><span class="p">,</span> <span class="n">size_nb_node_per_ele_vol</span><span class="p">,</span> 
         <span class="n">size_conn_vol</span><span class="p">)</span>

   <span class="c1"># si on donne une liste de sommets</span>
   <span class="k">if</span> <span class="p">(</span> <span class="n">vertices</span> <span class="p">):</span>
     <span class="c1"># on l&#39;utilise pour recuperer les coordonnees des noeuds</span>
      <span class="n">nodes</span> <span class="o">=</span> <span class="n">vertices</span>

   <span class="c1"># on cree un nouveau maillage 2D</span>
   <span class="n">surfacic_mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

   <span class="c1"># on initilialise l&#39;indice de debut de lecture dans le vecteur stockant la</span>
   <span class="c1"># table de connectivite des elements volumiques a 0</span>
   <span class="n">beg_conn</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="c1"># pour chaque element</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nb_node_per_ele_vol</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>

      <span class="c1"># on recupere la connectivite de l&#39;element, sous la forme d&#39;une liste</span>
      <span class="n">conn</span><span class="o">=</span><span class="n">conn_vol</span><span class="p">[</span><span class="n">beg_conn</span><span class="p">:</span><span class="n">beg_conn</span> <span class="o">+</span> <span class="n">nb_node_per_ele_vol</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

      <span class="c1"># si on a donne une liste de sommets</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">vertices</span> <span class="p">):</span>
         <span class="c1"># on verifie l&#39;orientation de l&#39;element </span>

         <span class="c1"># on recupere les coordonnees des trois premiers noeuds de l&#39;element</span>
         <span class="c1">#   * le premier noeud</span>
         <span class="n">k</span> <span class="o">=</span> <span class="n">conn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
         <span class="n">coor_1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
         <span class="c1">#   * le deuxieme noeud</span>
         <span class="n">k</span> <span class="o">=</span> <span class="n">conn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
         <span class="n">coor_2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
         <span class="c1">#   * le troisieme noeud</span>
         <span class="n">k</span> <span class="o">=</span> <span class="n">conn</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
         <span class="n">coor_3</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

         <span class="c1"># si (x2 - x1)*(y3 - y2) - (y2 - y1)*(x3 - x2) &lt; 0</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">coor_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">coor_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">coor_3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coor_2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="n">coor_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coor_1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">coor_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">coor_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="c1"># l&#39;element n&#39;est pas dans le bon sens</span>
            <span class="c1"># on le retourne</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

      <span class="c1"># on ajoute l&#39;element au maillage</span>
      <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">conn</span><span class="p">)</span> <span class="p">)</span>
      
      <span class="c1"># on met a jour l&#39;indice de debut de lecture</span>
      <span class="n">beg_conn</span> <span class="o">=</span> <span class="n">beg_conn</span> <span class="o">+</span> <span class="n">nb_node_per_ele_vol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

   <span class="c1"># pour chaque noeud</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
      <span class="c1"># on ajoute le noeud au maillage</span>
      <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span> <span class="n">node</span><span class="p">(</span> <span class="n">coor</span><span class="o">=</span><span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span> 
              <span class="n">number</span><span class="o">=</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span>

   <span class="c1"># on definit la tolerance pour la recherche de l&#39;appartenance des noeuds</span>
   <span class="c1"># aux groupes (&#39;left&#39;, &#39;down&#39;, &#39;right&#39;, ou &#39;up&#39;)</span>
   <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.01</span><span class="o">*</span><span class="nb">min</span><span class="p">(</span><span class="n">lx</span><span class="o">/</span><span class="n">nb_elem_x</span><span class="p">,</span> <span class="n">ly</span><span class="o">/</span><span class="n">nb_elem_y</span><span class="p">)</span> 
   <span class="c1"># on calcule les coordonnees du noeud en haut a droite du rectangle</span>
   <span class="n">x_max</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">lx</span>
   <span class="n">y_max</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">ly</span>  

   <span class="c1"># recherche de la surface libre, pour donner un groupe aux lignes la </span>
   <span class="c1"># composant</span>
   
   <span class="c1"># on definit un container pour stocker les listes d&#39;adjacence de chaque </span>
   <span class="c1"># noeud </span>
   <span class="n">l_node2ele</span> <span class="o">=</span> <span class="p">[]</span>
   
   <span class="c1"># pour chaque noeud du corps, on intialise une liste d&#39;adjacence vide</span>
   <span class="c1">#for n in body.nodes:</span>
   <span class="c1"># pour chaque noeud du maillage, on intialise une liste d&#39;adjacence vide</span>
   <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
      <span class="n">l_node2ele</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
   
   <span class="c1"># pour chaque element du maillage </span>
   <span class="c1">#for ele in body.bulks:</span>
   <span class="c1"># pour chaque element du maillage </span>
   <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># pour chaque noeud de l&#39;element</span>
      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
         <span class="c1"># on ajoute l&#39;element courant dans la liste d&#39;adjacence du noeud </span>
         <span class="c1"># courant</span>
         <span class="n">l_node2ele</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span>
   
   <span class="c1"># ici, la liste d&#39;adjacence de chaque noeud est remplie</span>
   
   <span class="c1"># on s&#39;en sert par la suite pour placer des contacteurs sur les elements de</span>
   <span class="c1"># la surface libre </span>
   
   <span class="c1"># pour chaque element</span>
   <span class="c1">#for ele in body.bulks:</span>
   <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># pour chaque noeud de l&#39;element</span>
      <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> 
         <span class="c1"># si l&#39;element est un Q8</span>
         <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;Q8xxx&#39;</span> <span class="ow">and</span> <span class="n">ic</span> <span class="o">&gt;=</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span>
            <span class="c1"># on laisse tomber les noeuds aux centres des lignes</span>
            <span class="k">continue</span>
         <span class="c1"># on recupere le numero du noeud</span>
         <span class="n">i</span> <span class="o">=</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span>
         <span class="c1"># et le numero du noeud suivant, dans la table de connectivite de</span>
         <span class="c1"># l&#39;element</span>
         <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;Q8xxx&#39;</span><span class="p">:</span> <span class="c1"># cas particulier du Q8</span>
            <span class="c1"># on recupere le noeud sommet suivant</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span>
         <span class="k">else</span><span class="p">:</span> <span class="c1"># cas general</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span><span class="p">]</span>
         <span class="c1"># (i, j) definit une arete de l&#39;element courant</span>
    
         <span class="c1"># on cehrche maintenant l&#39;element adjacent a l&#39;element courant par </span>
         <span class="c1"># cette arete </span>
   
         <span class="c1"># on indique qu&#39;on ne l&#39;a pas encore trouve</span>
         <span class="n">is_found</span> <span class="o">=</span> <span class="kc">None</span>
         <span class="c1"># pour chaque element ajdacent au noeud i</span>
         <span class="k">for</span> <span class="n">adj_ele</span> <span class="ow">in</span> <span class="n">l_node2ele</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># si on a trouve l&#39;element adjacent</span>
            <span class="k">if</span> <span class="n">is_found</span><span class="p">:</span>
               <span class="c1"># on sort de la boucle</span>
               <span class="k">break</span>
            <span class="c1"># si c&#39;est l&#39;element courant</span>
            <span class="k">if</span> <span class="n">ele</span> <span class="o">==</span> <span class="n">adj_ele</span><span class="p">:</span>
               <span class="c1"># on passe au suivant</span>
               <span class="k">continue</span>
            <span class="c1"># pour chaque noeud de l&#39;element adjacent courant</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">adj_ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
               <span class="c1"># si c&#39;est le noeud j</span>
               <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                  <span class="c1"># on a trouve l&#39;element adjacent a l&#39;element courant, par</span>
                  <span class="c1"># l&#39;arete (i, j)  </span>
                  <span class="n">is_found</span> <span class="o">=</span> <span class="mi">1</span>
                  <span class="c1"># on sort de la boucle</span>
                  <span class="k">break</span>

         <span class="c1"># si on n&#39;a pas trouve l&#39;element adjacent a l&#39;element courant par</span>
         <span class="c1"># l&#39;arete (i, j)</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">is_found</span><span class="p">:</span>
            <span class="c1"># alors l&#39;arete (i, j) fait partie de la surface libre et on </span>
            <span class="c1"># doit lui ajouter un ou plusieurs contacteurs</span>
              
            <span class="c1"># on cherche a quel groupe appartient l&#39;element</span>
            <span class="c1"># on recupere les coordonnees des noeuds i et j</span>
            <span class="n">ni</span> <span class="o">=</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">[</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">]</span> <span class="o">=</span> <span class="n">ni</span><span class="o">.</span><span class="n">coor</span>
            <span class="n">nj</span> <span class="o">=</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="p">[</span><span class="n">xj</span><span class="p">,</span> <span class="n">yj</span><span class="p">]</span> <span class="o">=</span> <span class="n">nj</span><span class="o">.</span><span class="n">coor</span>
            <span class="c1"># on determine le groupe de l&#39;element</span>
            <span class="c1"># si le maillage est en Q4</span>
            <span class="k">if</span> <span class="n">mesh_type</span> <span class="o">==</span> <span class="s1">&#39;Q4&#39;</span><span class="p">:</span>
               <span class="c1"># on utilise les inidces corespondant aux noeuds</span>

               <span class="c1"># on recuepre les indices pour le noeud i</span>
               <span class="n">u_i</span><span class="p">,</span> <span class="n">v_i</span> <span class="o">=</span> <span class="n">lmgc90</span><span class="o">.</span><span class="n">mesh2D_GetIndicesMeshQ4</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
               <span class="c1"># on recuepre les indices pour le noeud j</span>
               <span class="n">u_j</span><span class="p">,</span> <span class="n">v_j</span> <span class="o">=</span> <span class="n">lmgc90</span><span class="o">.</span><span class="n">mesh2D_GetIndicesMeshQ4</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>

               <span class="k">if</span> <span class="n">u_i</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">u_j</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                  <span class="c1"># cas d&#39;un element sur le bord gauche : x=x0</span>
                  <span class="n">pE</span><span class="o">=</span><span class="s1">&#39;left&#39;</span>
               <span class="k">if</span> <span class="n">v_i</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">v_j</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                  <span class="c1"># cas d&#39;un element sur le bord bas : y=y0</span>
                  <span class="n">pE</span><span class="o">=</span><span class="s1">&#39;down&#39;</span>
               <span class="k">if</span> <span class="n">u_i</span> <span class="o">==</span> <span class="n">nb_elem_x</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">u_j</span> <span class="o">==</span> <span class="n">nb_elem_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                  <span class="c1"># cas d&#39;un element sur le bord droit : x=x0 + lx</span>
                  <span class="n">pE</span><span class="o">=</span><span class="s1">&#39;right&#39;</span>
               <span class="k">if</span> <span class="n">v_i</span> <span class="o">==</span> <span class="n">nb_elem_y</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">v_j</span> <span class="o">==</span> <span class="n">nb_elem_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                  <span class="c1"># cas d&#39;un element sur le bord bas : y=y0 + ly</span>
                  <span class="n">pE</span><span class="o">=</span><span class="s1">&#39;up&#39;</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="c1"># on utlise la position des deux neouds </span>
               <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xi</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xj</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                  <span class="c1"># cas d&#39;un element sur le bord gauche : x=x0</span>
                  <span class="n">pE</span><span class="o">=</span><span class="s1">&#39;left&#39;</span>
               <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">yi</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">yj</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                  <span class="c1"># cas d&#39;un element sur le bord bas : y=y0</span>
                  <span class="n">pE</span><span class="o">=</span><span class="s1">&#39;down&#39;</span>
               <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xi</span> <span class="o">-</span> <span class="n">x_max</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xj</span> <span class="o">-</span> <span class="n">x_max</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                  <span class="c1"># cas d&#39;un element sur le bord droit : x=x0 + lx</span>
                  <span class="n">pE</span><span class="o">=</span><span class="s1">&#39;right&#39;</span>
               <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">yi</span> <span class="o">-</span> <span class="n">y_max</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">yj</span> <span class="o">-</span> <span class="n">y_max</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                  <span class="c1"># cas d&#39;un element sur le bord bas : y=y0 + ly</span>
                  <span class="n">pE</span><span class="o">=</span><span class="s1">&#39;up&#39;</span>

            <span class="c1"># on construit le nouvel element sur la surface libre : </span>
            <span class="c1">#   * cas particulier du Q8 : une ligne a trois noeuds</span>
            <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;Q8xxx&#39;</span><span class="p">:</span>
               <span class="c1"># on recupere le numero nu noeud au centre de l&#39;arete</span>
               <span class="n">k</span> <span class="o">=</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">ic</span> <span class="o">+</span> <span class="p">(</span><span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span> <span class="o">%</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span><span class="p">]</span> 
               <span class="c1"># ATTENTION: on conserve le sens trigonometrique de la</span>
               <span class="c1">#    description de la connectivite des Q8, pour definir la</span>
               <span class="c1">#    ligne a trois noeuds </span>
               <span class="n">surf</span> <span class="o">=</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="n">pE</span><span class="p">)</span>
            <span class="c1">#   * cas general : une ligne a deux noeuds</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="c1"># ATTENTION : la connectivite d&#39;une ligne supportant un </span>
               <span class="c1">#    contacteur est definie dans le sens anti-trigonometrique</span>
               <span class="n">surf</span> <span class="o">=</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">physicalEntity</span><span class="o">=</span><span class="n">pE</span><span class="p">)</span> 
   
            <span class="c1"># on ajoute l&#39;element au maillage</span>
            <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span><span class="n">surf</span><span class="p">)</span>

   <span class="c1"># on renvoie le maillage genere</span>
   <span class="k">return</span> <span class="n">surfacic_mesh</span></div>

<span class="c1"># fonction qui eclate un objet maille</span>
<div class="viewcode-block" id="explodeMeshedAvatar2D"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.explodeMeshedAvatar2D">[docs]</a><span class="k">def</span> <span class="nf">explodeMeshedAvatar2D</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">nbPoints</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;BLUEx&#39;</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
   <span class="sd">&#39;&#39;&#39;bodies=explodeMeshedAvatar2D(body, nbPoints=2, color=&#39;BLUEx&#39;, w=None):</span>

<span class="sd">   this function &quot;explodes&quot; a given 2D meshed avatar, i.e. gets a meshed avatar and returns a</span>
<span class="sd">   list of bodies, where each body is a cell of the given meshed avatar. Each new body</span>
<span class="sd">   have a list of contactor inherited from the connectivity of the given meshed avatar.</span>

<span class="sd">   parameters:</span>

<span class="sd">   - body: a 2D meshed avatar</span>

<span class="sd">   optional parameters:</span>

<span class="sd">   - nbPoints: number of points on the contactors candidate</span>
<span class="sd">   - color: default color of the contactors</span>
<span class="sd">   - w: vector of CLxxx positions </span>
<span class="sd">   - color_dict: a dictionnary associating a color to the physical entity of the element</span>
<span class="sd">   &#39;&#39;&#39;</span>

   <span class="c1"># on verifie que l&#39;objet est bien un maillage :</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">avatar</span><span class="p">):</span>
      <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;this object is not a body!&#39;</span><span class="p">)</span>
   <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">atype</span> <span class="o">!=</span> <span class="s1">&#39;MAILx&#39;</span><span class="p">:</span>
      <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;this body is not a MAILx!&#39;</span><span class="p">)</span>

   <span class="c1"># on verifie sa dimension</span>
   <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;this is function is designed for 2D bodies!&#39;</span><span class="p">)</span>

   <span class="c1"># on verifie que l&#39;objet soit maille avec des elements d&#39;ordre 1</span>
   <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;Q8xxx&#39;</span> <span class="ow">or</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;T6xxx&#39;</span><span class="p">:</span> 
         <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;this function is designed for linear elements!&#39;</span><span class="p">)</span>

   <span class="c1"># on definit une liste d&#39;avatar, qui va contenir la liste des elements </span>
   <span class="c1"># devenus corps independants</span>
   <span class="n">bodies</span> <span class="o">=</span> <span class="n">avatars</span><span class="p">()</span>

   <span class="c1"># on definit :</span>
   <span class="c1">#   *  la table qui associe un numero d&#39;element du maillage a l&#39;indice du nouveau corps</span>
   <span class="c1">#      qui lui correspond</span>
   <span class="n">ele2bodyIndex</span><span class="o">=</span><span class="p">{}</span>
   <span class="c1">#   *  la table qui associe un numero d&#39;element d&#39;un nouveau corps au numero d&#39;element du maillage</span>
   <span class="c1">#      qui lui correspond</span>
   <span class="n">body2eleIndex</span><span class="o">=</span><span class="p">{}</span>

   <span class="k">if</span> <span class="ow">not</span> <span class="n">color_dict</span><span class="p">:</span>
     <span class="n">color_dict</span> <span class="o">=</span> <span class="p">{}</span>

   <span class="c1"># on cree un corps pour chaque element fini</span>

   <span class="n">bodyIndex</span><span class="o">=</span><span class="mi">0</span>
   <span class="c1"># pour chaque element fini</span>
   <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si l&#39;element n&#39;est pas un element de surface</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
         <span class="c1"># on saute l&#39;element</span>
         <span class="k">continue</span>

      <span class="c1"># on ajoute le nouveau corps dans la table qui associe un numero d&#39;element du maillage</span>
      <span class="c1"># a l&#39;indice du nouveau corps</span>
      <span class="n">ele2bodyIndex</span><span class="p">[</span><span class="n">ele</span><span class="o">.</span><span class="n">number</span><span class="p">]</span><span class="o">=</span><span class="n">bodyIndex</span>
      <span class="c1"># et dans la table qui associe l&#39;indice du nouveau corps au numero d&#39;element du maillage</span>
      <span class="n">body2eleIndex</span><span class="p">[</span><span class="n">bodyIndex</span><span class="p">]</span><span class="o">=</span><span class="n">ele</span><span class="o">.</span><span class="n">number</span>

      <span class="n">bodyIndex</span> <span class="o">+=</span> <span class="mi">1</span>

      <span class="c1"># on cree un nouveau corps maille 2D</span>
      <span class="n">new_body</span> <span class="o">=</span> <span class="n">avatar</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
      <span class="c1"># on ajoute au nouveau corps un nouvel element fini, du meme type que</span>
      <span class="c1"># l&#39;element courant mais dont la connectivite est triviale</span>
      <span class="c1"># N.B.: on conserve la physical entity, i.e. le groupe de l&#39;element</span>
      <span class="n">new_body</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="n">geoElement2dimension</span><span class="p">[</span><span class="n">ele</span><span class="o">.</span><span class="n">etype</span><span class="p">],</span>
                                <span class="n">connectivity</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                                <span class="n">physicalEntity</span><span class="o">=</span><span class="n">ele</span><span class="o">.</span><span class="n">physicalEntity</span><span class="p">)</span> <span class="p">)</span>

      <span class="c1"># on ajoute au corps les seuls noeuds dont il a besoin</span>
       
      <span class="c1"># on initialise le nombre de noeuds du nouvel element a 0</span>
      <span class="n">nbNodes</span><span class="o">=</span><span class="mi">0</span>
      <span class="c1"># pour chaque noeud de l&#39;element courant</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
         <span class="c1"># on incremente le nombre de noeuds du nouvel element         </span>
         <span class="n">nbNodes</span> <span class="o">+=</span> <span class="mi">1</span>
         <span class="c1"># on recupere l&#39;objet node associe</span>
         <span class="n">n</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
         <span class="c1"># on peut alors construire le nouveau noeud, connaissant ses </span>
         <span class="c1"># coordonnees</span>
         <span class="n">new_body</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span> <span class="n">node</span><span class="p">(</span> <span class="n">coor</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="n">coor</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="n">nbNodes</span><span class="p">)</span> <span class="p">)</span>

      <span class="c1"># on ajoute le corps genere au container</span>
      <span class="n">bodies</span> <span class="o">+=</span> <span class="n">new_body</span>

   <span class="c1"># on definit un container pour stocker les listes d&#39;adjacence de chaque </span>
   <span class="c1"># noeud </span>
   <span class="n">l_node2ele</span> <span class="o">=</span> <span class="p">[]</span>

   <span class="c1"># pour chaque noeud du corps, on intialise une liste d&#39;adjacence vide</span>
   <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
      <span class="n">l_node2ele</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

   <span class="c1"># pour chaque element du maillage </span>
   <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si l&#39;element n&#39;est pas un element de surface</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
         <span class="c1"># on saute l&#39;element</span>
         <span class="k">continue</span>
      <span class="c1"># pour chaque noeud de l&#39;element</span>
      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
         <span class="c1"># on ajoute l&#39;element courant dans la liste d&#39;adjacence du noeud </span>
         <span class="c1"># courant</span>
         <span class="n">l_node2ele</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span>

   <span class="c1"># ici, la liste d&#39;adjacence de chaque noeud est remplie</span>

   <span class="c1"># on s&#39;en sert par la suite pour placer des contacteurs sur les elements de</span>
   <span class="c1"># la surface libre </span>

   <span class="c1"># pour chaque element</span>
   <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>

      <span class="c1"># si l&#39;element n&#39;est pas un element de surface</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
         <span class="c1"># on saute l&#39;element</span>
         <span class="k">continue</span>

      <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ele</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">physics</span> <span class="o">==</span> <span class="s1">&#39;MECAx&#39;</span> <span class="p">):</span>
         <span class="k">continue</span>

      <span class="c1"># pour chaque noeud de l&#39;element</span>
      <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> 
         <span class="c1"># on recupere le numero du noeud</span>
         <span class="n">i</span> <span class="o">=</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span>
         <span class="c1"># et le numero du noeud suivant, dans la table de connectivite de</span>
         <span class="c1"># l&#39;element</span>
         <span class="n">j</span> <span class="o">=</span> <span class="n">ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span><span class="p">]</span>
         <span class="c1"># (i, j) definit une arete de l&#39;element courant</span>

         <span class="c1"># on cherche maintenant l&#39;element adjacent a l&#39;element courant par </span>
         <span class="c1"># cette arete </span>

         <span class="c1"># on indique qu&#39;on ne l&#39;a pas encore trouve</span>
         <span class="n">is_found</span> <span class="o">=</span> <span class="kc">None</span>
         <span class="n">found_ele</span> <span class="o">=</span> <span class="kc">None</span>
         <span class="c1"># pour chaque element ajdacent au noeud i</span>
         <span class="k">for</span> <span class="n">adj_ele</span> <span class="ow">in</span> <span class="n">l_node2ele</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># si on a trouve l&#39;element adjacent</span>
            <span class="k">if</span> <span class="n">is_found</span><span class="p">:</span>
               <span class="c1"># on sort de la boucle</span>
               <span class="k">break</span>
            <span class="c1"># si c&#39;est l&#39;element courant</span>
            <span class="k">if</span> <span class="n">ele</span> <span class="o">==</span> <span class="n">adj_ele</span><span class="p">:</span>
               <span class="c1"># on passe au suivant</span>
               <span class="k">continue</span>
            <span class="c1"># pour chaque noeud de l&#39;element adjacent courant</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">adj_ele</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
               <span class="c1"># si c&#39;est le noeud j</span>
               <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                  <span class="c1"># on a trouve l&#39;element adjacent a l&#39;element courant, par</span>
                  <span class="c1"># l&#39;arete (i, j)  </span>
                  <span class="n">is_found</span> <span class="o">=</span> <span class="mi">1</span>
                  <span class="n">found_ele</span> <span class="o">=</span> <span class="n">adj_ele</span>
                  <span class="c1"># on sort de la boucle</span>
                  <span class="k">break</span>

         <span class="c1"># si on a trouve l&#39;element adjacent a l&#39;element courant par</span>
         <span class="c1"># l&#39;arete (i, j)</span>
         <span class="k">if</span> <span class="n">is_found</span><span class="p">:</span>
            <span class="c1"># l&#39;arete (i, j) est dans le volume, et on doit porter des</span>
            <span class="c1"># contacteur candidat et antagoniste en vis-a-vis</span>

            <span class="c1"># on recupere le nouveau corps associe a l&#39;element courant</span>
            <span class="n">new_body</span> <span class="o">=</span> <span class="n">bodies</span><span class="p">[</span><span class="n">ele2bodyIndex</span><span class="p">[</span><span class="n">ele</span><span class="o">.</span><span class="n">number</span><span class="p">]]</span>
            <span class="c1"># on construit l&#39;element qui supporte le contacteur : une ligne</span>
            <span class="c1"># a deux noeuds</span>
            <span class="c1"># ATTENTION : la connectivite d&#39;une ligne supportant un contacteur</span>
            <span class="c1">#    est definie dans le sens anti-trigonometrique</span>
            <span class="n">surf</span> <span class="o">=</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="p">[(</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># on positionne un contacteur sur l&#39;element courant, en fonction </span>
            <span class="c1"># de son numero</span>
            <span class="k">try</span><span class="p">:</span>
              <span class="n">col</span> <span class="o">=</span> <span class="n">color_dict</span><span class="p">[</span><span class="n">ele</span><span class="o">.</span><span class="n">physicalEntity</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
              <span class="n">col</span> <span class="o">=</span> <span class="n">color</span>

            <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">number</span> <span class="o">&gt;</span> <span class="n">found_ele</span><span class="o">.</span><span class="n">number</span><span class="p">:</span>
               <span class="c1"># si son numero est plus grand que celui de l&#39;element adjacent</span>
               <span class="c1"># il porte des noeuds candidats</span>

               <span class="c1"># on initialise a vide la liste des poids associes aux points</span>
               <span class="c1"># candidats</span>
               <span class="n">weights</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbPoints</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
               <span class="c1"># Est ce que les poids sont fournis en argument</span>
               <span class="k">if</span> <span class="p">(</span> <span class="n">w</span> <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">w</span> <span class="p">)</span> <span class="o">==</span> <span class="n">nbPoints</span> <span class="p">):</span>
                  <span class="c1"># On prend ceux la </span>
                  <span class="n">weights</span><span class="o">=</span><span class="n">w</span>
               <span class="c1"># sinon on les calcul</span>
               <span class="k">else</span><span class="p">:</span>
                  <span class="c1"># pour chaque noeud candidat</span>
                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbPoints</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                     <span class="c1"># on calcule le poids associe au point courant</span>
                     <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="n">nbPoints</span>
               <span class="c1"># on cree un contacteur candidat</span>
               <span class="n">cd</span> <span class="o">=</span> <span class="n">contactorFactory</span><span class="p">(</span><span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="s1">&#39;CLxxx&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">col</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
               <span class="c1"># on l&#39;ajoute au nouveau corps corespondant a l&#39;element </span>
               <span class="c1"># courant</span>
               <span class="c1"># N.B.: on utilise ici une methode privee de la classe avatar</span>
               <span class="c1">#       a dessein! Cette methode est declaree privee pour qu&#39;elle</span>
               <span class="c1">#       ne soit pas utilisee dans les scripts utilisateurs. Ici,</span>
               <span class="c1">#       on sait ce qu&#39;on fait en ajoutant un contacteur a la main!</span>
               <span class="n">new_body</span><span class="o">.</span><span class="n">_addContactor</span><span class="p">(</span><span class="n">cd</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="c1"># sinon, il porte une ligne antagoniste            </span>
                
               <span class="c1"># on cree un contacteur antagoniste</span>
               <span class="n">an</span> <span class="o">=</span> <span class="n">contactorFactory</span><span class="p">(</span><span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="s1">&#39;ALpxx&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">col</span><span class="p">)</span>
               <span class="c1"># on l&#39;ajoute au nouveau corps corespondant a l&#39;element </span>
               <span class="c1"># courant</span>
               <span class="c1"># N.B.: on utilise ici une methode privee de la classe avatar</span>
               <span class="c1">#       a dessein! Cette methode est declaree privee pour qu&#39;elle</span>
               <span class="c1">#       ne soit pas utilisee dans les scripts utilisateurs. Ici,</span>
               <span class="c1">#       on sait ce qu&#39;on fait en ajoutant un contacteur a la main!</span>
               <span class="n">new_body</span><span class="o">.</span><span class="n">_addContactor</span><span class="p">(</span><span class="n">an</span><span class="p">)</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="c1"># sinon, l&#39;arete appartient a la surface libre et doit recuperer</span>
            <span class="c1"># l&#39;element ligne associe, s&#39;il existe</span>

            <span class="c1"># on definit un objet pour recevoir l&#39;element ligne associe</span>
            <span class="n">found_line</span> <span class="o">=</span> <span class="kc">None</span> 
            <span class="c1"># pour chaque element</span>
            <span class="k">for</span> <span class="n">ele_surf</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
               <span class="c1"># si l&#39;element n&#39;est pas une ligne</span>
               <span class="k">if</span> <span class="n">ele_surf</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;S2xxx&#39;</span><span class="p">:</span>
                  <span class="c1"># on passe au suivant</span>
                  <span class="k">continue</span>
               <span class="c1"># si la connectivite correspond</span>
               <span class="k">if</span> <span class="n">ele_surf</span><span class="o">.</span><span class="n">connectivity</span> <span class="o">==</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="ow">or</span> <span class="n">ele_surf</span><span class="o">.</span><span class="n">connectivity</span> <span class="o">==</span> <span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                  <span class="c1"># on a trouve l&#39;element ligne </span>
                  <span class="n">found_line</span> <span class="o">=</span> <span class="n">ele_surf</span>
                  <span class="c1"># on sort de la boucle</span>
                  <span class="k">break</span>

            <span class="c1"># si l&#39;element ligne associe existe</span>
            <span class="k">if</span> <span class="n">found_line</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
               <span class="c1"># on recupere le nouveau corps associe a l&#39;element courant</span>
               <span class="n">new_body</span> <span class="o">=</span> <span class="n">bodies</span><span class="p">[</span><span class="n">ele2bodyIndex</span><span class="p">[</span><span class="n">ele</span><span class="o">.</span><span class="n">number</span><span class="p">]]</span>
               <span class="c1"># on cree l&#39;element ligne a ajouter au corps</span>
               <span class="c1"># ATTENTION : la connectivite d&#39;une ligne supportant un </span>
               <span class="c1">#    contacteur est definie dans le sens anti-trigonometrique</span>
               <span class="n">surf</span> <span class="o">=</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                              <span class="n">connectivity</span><span class="o">=</span><span class="p">[(</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ele</span><span class="o">.</span><span class="n">nbNodes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                              <span class="n">physicalEntity</span><span class="o">=</span><span class="n">found_line</span><span class="o">.</span><span class="n">physicalEntity</span><span class="p">)</span>
               <span class="c1"># on l&#39;ajoute au nouveau corps</span>
               <span class="n">new_body</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span><span class="n">surf</span><span class="p">)</span>

            <span class="c1"># else:</span>
            <span class="c1">#    print(&#39;wtf&#39;)</span>
            <span class="c1">#    print(ele.etype)</span>
            <span class="c1">#    print(ele.physicalEntity)</span>
            <span class="c1">#    print(i,j)</span>

   <span class="c1"># on enumere les nouveau avatars</span>
   <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">new_body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bodies</span><span class="p">):</span>
      <span class="c1"># on definit la liste des groupes du nouveau corps</span>
      <span class="n">new_body</span><span class="o">.</span><span class="n">defineGroups</span><span class="p">()</span>
      <span class="c1"># on recupere l&#39;element de l&#39;avatar continu, auquel est associe le</span>
      <span class="c1"># nouveau corps courant</span>
      <span class="n">bulk</span><span class="o">=</span><span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">body2eleIndex</span><span class="p">[</span><span class="n">num</span><span class="p">]]</span>
      <span class="c1"># on attribue au nouveau corps le modele de l&#39;element de l&#39;avatar</span>
      <span class="c1"># continu qui lui associe</span>
      <span class="n">new_body</span><span class="o">.</span><span class="n">defineModel</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
      <span class="c1"># on attribue au nouveau corps le materiau de l&#39;element de l&#39;avatar</span>
      <span class="c1"># continu qui lui associe</span>
      <span class="n">new_body</span><span class="o">.</span><span class="n">defineMaterial</span><span class="p">(</span><span class="n">material</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">material</span><span class="p">)</span>
 
   <span class="c1"># on renvoie le container de corps genere</span>
   <span class="k">return</span> <span class="n">bodies</span></div>


<span class="c1"># fonction qui insert des fissures dans un objet maille</span>
<div class="viewcode-block" id="crackMeshedAvatar2D"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.crackMeshedAvatar2D">[docs]</a><span class="k">def</span> <span class="nf">crackMeshedAvatar2D</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">crackgroup</span><span class="p">):</span>
   <span class="sd">&#39;&#39;&#39;newbody,newgroups = crackMeshedAvatar2D(body, crackgroup):</span>

<span class="sd">   this function had a set of &quot;cracks&quot; to a given 2D meshed avatar</span>
<span class="sd">   it adds nodes and 1D elements along the crack </span>

<span class="sd">   parameters:</span>

<span class="sd">   - (I) body: a 2D meshed avatar</span>
<span class="sd">   - (I) crackgroup: the group name of 1D elements concerned by cracking</span>
<span class="sd">   - (O) newbody : a new 2D meshed with additional nodes and 1D elements along crackgroup</span>
<span class="sd">   - (O) newgroups : a list of groups created while adding new nodes and 1D elements</span>
<span class="sd">   &#39;&#39;&#39;</span>

   <span class="n">bavard</span><span class="o">=</span><span class="mi">0</span>
   
   <span class="c1"># on verifie que l&#39;objet est bien un maillage :</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">avatar</span><span class="p">):</span>
      <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::this object is not a body!&#39;</span><span class="p">)</span>
   <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">atype</span> <span class="o">!=</span> <span class="s1">&#39;MAILx&#39;</span><span class="p">:</span>
      <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::this body is not a MAILx!&#39;</span><span class="p">)</span>

   <span class="c1"># on verifie sa dimension</span>
   <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::this is function is designed for 2D bodies!&#39;</span><span class="p">)</span>

   <span class="c1"># on verifie que l&#39;objet soit maille avec des elements d&#39;ordre 1</span>
   <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;Q8xxx&#39;</span> <span class="ow">or</span> <span class="n">ele</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;T6xxx&#39;</span><span class="p">:</span> 
         <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::this function is designed for linear elements!&#39;</span><span class="p">)</span>

   <span class="c1"># on construit la map noeud -&gt; elements 2D </span>
   <span class="n">node2ele_</span> <span class="o">=</span> <span class="p">{}</span>
   <span class="c1"># pour chaque element du maillage </span>
   <span class="k">for</span> <span class="n">ele_</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si l&#39;element est 2D</span>
      <span class="k">if</span> <span class="n">ele_</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
        <span class="c1"># pour chaque noeud de l&#39;element</span>
        <span class="k">for</span> <span class="n">n_</span> <span class="ow">in</span> <span class="n">ele_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
           <span class="c1"># on ajoute l&#39;element dans la liste d&#39;adjacence du noeud</span>
           <span class="n">node2ele_</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">n_</span><span class="p">,[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ele_</span><span class="p">)</span>

   <span class="c1"># on reconstruit la topo des lignes (liste des elements 1D portes par une ligne)</span>
   <span class="n">lines_</span> <span class="o">=</span> <span class="p">{}</span>
   <span class="k">for</span> <span class="n">bulk_</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">crackgroup</span><span class="p">]</span><span class="o">.</span><span class="n">bulks</span> <span class="p">:</span>
     <span class="k">if</span> <span class="n">bulk_</span><span class="o">.</span><span class="n">nbNodes</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">:</span>
       <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::strange this element should have only 2 nodes&#39;</span><span class="p">)</span>
     <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">bulk_</span><span class="o">.</span><span class="n">geometricalEntity</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">9999</span> <span class="p">:</span>
      <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::geometricalEntity rank greater than 9999 which is incompatible with new groups numbering (4 characters)&#39;</span><span class="p">)</span>        
     <span class="n">lines_</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">bulk_</span><span class="o">.</span><span class="n">geometricalEntity</span><span class="p">,[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bulk_</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>

   <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number of crack lines &#39;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">lines_</span><span class="p">))</span> 
   
   <span class="c1"># looking for lines extremities</span>
   <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--lines extremity and internal nodes--&quot;</span><span class="p">)</span>
   
   <span class="n">lines_extremity_nodes_</span> <span class="o">=</span> <span class="p">{}</span>
   <span class="n">lines_internal_nodes_</span><span class="o">=</span><span class="p">{}</span>
   
   <span class="k">for</span> <span class="p">(</span><span class="n">g_</span><span class="p">,</span><span class="n">line_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">lines_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
     <span class="n">beg_</span><span class="o">=</span><span class="p">[]</span>
     <span class="n">end_</span><span class="o">=</span><span class="p">[]</span>
     <span class="k">for</span> <span class="n">ele_</span> <span class="ow">in</span> <span class="n">line_</span><span class="p">:</span>
       <span class="n">beg_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">ele_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
       <span class="n">end_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">ele_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
     
     <span class="n">lines_extremity_nodes_</span><span class="p">[</span><span class="n">g_</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">beg_</span><span class="p">)</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">end_</span><span class="p">)</span>
     <span class="n">lines_internal_nodes_</span><span class="p">[</span><span class="n">g_</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">beg_</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">end_</span><span class="p">)</span>
     
     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines_extremity_nodes_</span><span class="p">[</span><span class="n">g_</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
       <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;line &#39;</span><span class="p">,</span><span class="n">g_</span><span class="p">,</span><span class="s1">&#39;is a closed loop&#39;</span><span class="p">)</span>
       <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::closed loop not managed yet&#39;</span><span class="p">)</span>

     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines_extremity_nodes_</span><span class="p">[</span><span class="n">g_</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
       <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;line &#39;</span><span class="p">,</span><span class="n">g_</span><span class="p">,</span><span class="s1">&#39;has more than 2 extremities&#39;</span><span class="p">)</span>
       <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::strange loop not managed yet&#39;</span><span class="p">)</span>

   <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span>
     <span class="k">for</span> <span class="n">g_</span><span class="p">,</span><span class="n">v_</span> <span class="ow">in</span> <span class="n">lines_extremity_nodes_</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;line &#39;</span><span class="p">,</span><span class="n">g_</span><span class="p">,</span><span class="s1">&#39; extremities &#39;</span><span class="p">,</span><span class="n">v_</span><span class="p">)</span>
       
   <span class="c1"># looking for corners</span>
   <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--corners--&quot;</span><span class="p">)</span>
   
   <span class="c1"># pour chaque coin on veut stocker un set de ligne</span>
   <span class="n">corners_</span><span class="o">=</span><span class="p">{}</span>
   <span class="c1"># fd dit &quot;recherche n^2 de merde&quot; (xg_|yg_ index ligne xx_|yy_ noeuds extermites) </span>
   <span class="k">for</span> <span class="p">(</span><span class="n">xg_</span><span class="p">,</span><span class="n">xx_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">lines_extremity_nodes_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> 
      <span class="k">for</span> <span class="p">(</span><span class="n">yg_</span><span class="p">,</span><span class="n">yy_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">lines_extremity_nodes_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
         <span class="k">if</span> <span class="n">yg_</span> <span class="o">==</span> <span class="n">xg_</span> <span class="p">:</span> <span class="k">continue</span>
         <span class="n">c_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">xx_</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">yy_</span><span class="p">)</span>
         <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span> <span class="k">continue</span>
         <span class="c1"># if bavard : print(&#39;possible corner node &#39;,c_,&#39; between line &#39;,xg_,&#39; and line &#39;,yg_)</span>
         <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
           <span class="n">k_</span><span class="o">=</span><span class="n">c_</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
           <span class="c1"># si deja stocke on oublie</span>
           <span class="k">if</span> <span class="n">k_</span> <span class="ow">in</span> <span class="n">corners_</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">xg_</span> <span class="ow">in</span> <span class="n">corners_</span><span class="p">[</span><span class="n">k_</span><span class="p">]</span> <span class="ow">and</span> <span class="n">yg_</span> <span class="ow">in</span> <span class="n">corners_</span><span class="p">[</span><span class="n">k_</span><span class="p">]):</span>
             <span class="k">continue</span> 
           <span class="k">else</span> <span class="p">:</span>
             <span class="c1"># if bavard : print(&#39;keep corner node &#39;,k_,&#39; between line &#39;,xg_,&#39; and line &#39;,yg_)</span>
             <span class="k">if</span> <span class="n">k_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">corners_</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">:</span>
               <span class="n">corners_</span><span class="p">[</span><span class="n">k_</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
             <span class="n">corners_</span><span class="p">[</span><span class="n">k_</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">xg_</span><span class="p">,</span><span class="n">yg_</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">corners_</span><span class="p">[</span><span class="n">k_</span><span class="p">])</span>                
             <span class="c1"># corners_.setdefault(k_,set()).set([xg_,yg_]).union(corners_[k_]) </span>
         <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">:</span>
           <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::more than 1 corner node between line &#39;</span><span class="p">,</span><span class="n">xg_</span><span class="p">,</span><span class="s1">&#39; and line &#39;</span><span class="p">,</span><span class="n">yg_</span><span class="p">,</span><span class="s1">&#39; impossible &#39;</span><span class="p">)</span>

   <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span>       
     <span class="k">for</span> <span class="p">(</span><span class="n">corner_</span><span class="p">,</span><span class="n">e_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">corners_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">corner_</span><span class="p">,</span><span class="s1">&#39; is corner of lines &#39;</span><span class="p">,</span><span class="n">e_</span><span class="p">)</span>
    
   <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--adding nodes along lines--&quot;</span><span class="p">)</span>
   <span class="c1"># numero de noeud max avant de toucher (attention on commence a 1)</span>
   <span class="n">nbn_</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
   <span class="c1"># on va dupliquer les noeuds</span>
   <span class="c1"># map ancien -&gt; nouveau</span>
   <span class="n">n2nn_</span><span class="o">=</span><span class="p">{}</span>
   <span class="c1"># map nouveau -&gt; ancien</span>
   <span class="n">nn2n_</span><span class="o">=</span><span class="p">{}</span>
   <span class="c1"># boucle sur les lignes</span>
   <span class="k">for</span> <span class="p">(</span><span class="n">g_</span><span class="p">,</span><span class="n">line_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">lines_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
     <span class="c1"># print(&#39;line&#39;,g_,&#39; internal nodes &#39;,lines_internal_nodes_[g_])       </span>
     <span class="c1"># on duplique les noeuds</span>
     <span class="k">for</span> <span class="n">n_</span> <span class="ow">in</span> <span class="n">lines_internal_nodes_</span><span class="p">[</span><span class="n">g_</span><span class="p">]:</span>
       <span class="n">coor_</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n_</span><span class="p">]</span><span class="o">.</span><span class="n">coor</span>
       <span class="n">nb_</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
       <span class="n">body</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">coor</span><span class="o">=</span><span class="n">coor_</span><span class="p">,</span><span class="n">number</span><span class="o">=</span><span class="n">nb_</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
       <span class="n">nn_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
       <span class="c1"># print(n_,&#39; -&gt; &#39;,nn_)</span>
       <span class="n">n2nn_</span><span class="p">[</span><span class="n">n_</span><span class="p">]</span><span class="o">=</span><span class="n">nn_</span>
       <span class="n">nn2n_</span><span class="p">[</span><span class="n">nn_</span><span class="p">]</span><span class="o">=</span><span class="n">n_</span>       
       <span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">nn_</span><span class="p">]</span><span class="o">.</span><span class="n">dof</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n_</span><span class="p">]</span><span class="o">.</span><span class="n">dof</span>
       
   <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--modifying elements along lines--&quot;</span><span class="p">)</span>
   <span class="n">algrp_</span><span class="o">=</span><span class="p">[]</span>
   <span class="k">for</span> <span class="p">(</span><span class="n">g_</span><span class="p">,</span><span class="n">line_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">lines_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
     <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;line&#39;</span><span class="p">,</span><span class="n">g_</span><span class="p">,</span><span class="s1">&#39; nb segments &#39;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">line_</span><span class="p">))</span>

     <span class="c1"># on cree un nom de groupe pour les AL</span>
     <span class="n">name_</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;*****&#39;</span><span class="p">)</span>
     <span class="n">grp_</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">g_</span><span class="p">)</span>
     <span class="n">name_</span><span class="p">[</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">grp_</span><span class="p">):]</span><span class="o">=</span><span class="n">grp_</span>
     <span class="n">grp_</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">name_</span><span class="p">)</span>
     <span class="n">algrp_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grp_</span><span class="p">)</span>

     <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;creating group &#39;</span><span class="p">,</span><span class="n">grp_</span><span class="p">,</span><span class="s1">&#39; for elements in front of line &#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">g_</span><span class="p">))</span>
     
     <span class="c1"># pour chaque segment de la ligne on cherche les elements d&#39;appui</span>
     <span class="c1"># et suivant l&#39;orientation du cote on change par les noeuds dupliques</span>
     <span class="c1"># adj_={} </span>
     <span class="k">for</span> <span class="n">ele_</span> <span class="ow">in</span> <span class="n">line_</span><span class="p">:</span>
        
       <span class="n">i_</span><span class="o">=</span><span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">ele_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
       <span class="n">j_</span><span class="o">=</span><span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">ele_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
       <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;segment &#39;</span><span class="p">,</span><span class="n">i_</span><span class="p">,</span><span class="n">j_</span><span class="p">)</span>
       
       <span class="c1"># les nouveaux noeuds</span>
       <span class="n">ni_</span> <span class="o">=</span> <span class="n">i_</span> 
       <span class="n">nj_</span> <span class="o">=</span> <span class="n">j_</span>

       <span class="c1"># recherche elements de chaque cote du segment</span>
       <span class="n">inter_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">node2ele_</span><span class="p">[</span><span class="n">i_</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">node2ele_</span><span class="p">[</span><span class="n">j_</span><span class="p">])</span>

       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
         <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::edge &#39;</span><span class="p">,</span><span class="n">i_</span><span class="p">,</span><span class="s1">&#39; and &#39;</span><span class="p">,</span><span class="n">i_</span><span class="p">,</span><span class="s1">&#39; without supporting element is impossible &#39;</span><span class="p">)</span>

       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="p">:</span>
         <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::edge &#39;</span><span class="p">,</span><span class="n">i_</span><span class="p">,</span><span class="s1">&#39; and &#39;</span><span class="p">,</span><span class="n">i_</span><span class="p">,</span><span class="s1">&#39; with more than 2 supporting elements is impossible &#39;</span><span class="p">)</span>

       <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span>  
         <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;edge &#39;</span><span class="p">,</span><span class="n">i_</span><span class="p">,</span><span class="s1">&#39; -&gt; &#39;</span><span class="p">,</span><span class="n">j_</span><span class="p">,</span><span class="s1">&#39; shared by &#39;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">),</span><span class="s1">&#39; elements &#39;</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">e_</span> <span class="ow">in</span> <span class="n">inter_</span><span class="p">:</span>
           <span class="nb">print</span><span class="p">(</span><span class="n">e_</span><span class="o">.</span><span class="n">number</span><span class="p">,</span><span class="s1">&#39; connectivity &#39;</span><span class="p">,</span> <span class="n">e_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[:])</span>

       <span class="c1"># on duplique si bien 2 elements en vis a vis  </span>
       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
         <span class="n">e1_</span> <span class="o">=</span> <span class="n">inter_</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
         <span class="n">e2_</span> <span class="o">=</span> <span class="n">inter_</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

         <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span>
           <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;initial elements&#39;</span><span class="p">)</span>
           <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;e1_&#39;</span><span class="p">,</span><span class="n">e1_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>
           <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;e2_&#39;</span><span class="p">,</span><span class="n">e2_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>
         
         <span class="k">try</span> <span class="p">:</span>          
           <span class="n">idi_</span><span class="o">=</span> <span class="n">e1_</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i_</span><span class="p">)</span>
         <span class="k">except</span><span class="p">:</span> 
           <span class="n">idi_</span><span class="o">=</span> <span class="n">e1_</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n2nn_</span><span class="p">[</span><span class="n">i_</span><span class="p">])</span>
           
         <span class="c1"># si i_,j_ se suivent dans e1_ on change e2_ (sens j_,i_)</span>
         <span class="k">if</span> <span class="n">j_</span> <span class="o">==</span> <span class="n">e1_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">idi_</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">e1_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)]</span> <span class="p">:</span>
           <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;modifying e2_&#39;</span><span class="p">)</span> 

           <span class="k">if</span> <span class="n">i_</span> <span class="ow">in</span> <span class="n">lines_internal_nodes_</span><span class="p">[</span><span class="n">g_</span><span class="p">]</span> <span class="p">:</span>
             <span class="c1"># peut avoir ete change ... </span>
             <span class="k">try</span> <span class="p">:</span>
               <span class="n">idi_</span> <span class="o">=</span>  <span class="n">e2_</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i_</span><span class="p">)</span>
               <span class="n">e2_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">idi_</span><span class="p">]</span> <span class="o">=</span> <span class="n">n2nn_</span><span class="p">[</span><span class="n">i_</span><span class="p">]</span>
               <span class="n">ni_</span> <span class="o">=</span> <span class="n">n2nn_</span><span class="p">[</span><span class="n">i_</span><span class="p">]</span>
             <span class="k">except</span> <span class="p">:</span>
               <span class="n">idi_</span> <span class="o">=</span> <span class="n">e2_</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n2nn_</span><span class="p">[</span><span class="n">i_</span><span class="p">])</span>
               <span class="c1"># on ne touche pas ni_ puisque deja modifie</span>
             
             <span class="c1"># on cherche l element voisins de e2_ par bord i_-&gt; i_+1</span>
             <span class="n">ii_</span> <span class="o">=</span> <span class="n">e2_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">idi_</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">e2_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)]</span>
             <span class="c1"># si noeud ii_ deja modifie on recupere le precedent</span>
             <span class="k">if</span> <span class="n">ii_</span> <span class="o">&gt;</span> <span class="n">nbn_</span> <span class="p">:</span> <span class="n">ii_</span> <span class="o">=</span> <span class="n">nn2n_</span><span class="p">[</span><span class="n">ii_</span><span class="p">]</span>
             <span class="n">inter_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">node2ele_</span><span class="p">[</span><span class="n">ii_</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">node2ele_</span><span class="p">[</span><span class="n">i_</span><span class="p">])</span>
             <span class="c1"># len(inter)==1 c est e2</span>
             <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
               <span class="n">e3_</span><span class="o">=</span> <span class="n">inter_</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
               <span class="k">if</span> <span class="n">e3_</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">e2_</span><span class="o">.</span><span class="n">number</span> <span class="p">:</span> <span class="n">e3_</span> <span class="o">=</span> <span class="n">inter_</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
               <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;neighbour before &#39;</span><span class="p">,</span><span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>               
               <span class="c1"># on fait le try car le noeud pourrait avoir deja ete change</span>
               <span class="k">try</span> <span class="p">:</span>
                 <span class="n">idi_</span> <span class="o">=</span> <span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i_</span><span class="p">)</span>
                 <span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">idi_</span><span class="p">]</span> <span class="o">=</span> <span class="n">n2nn_</span><span class="p">[</span><span class="n">i_</span><span class="p">]</span>
               <span class="k">except</span><span class="p">:</span>
                 <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i_</span><span class="p">,</span><span class="s1">&#39; already changed in &#39;</span><span class="p">,</span> <span class="n">n2nn_</span><span class="p">[</span><span class="n">i_</span><span class="p">])</span> 
                 <span class="k">pass</span>
               <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;neighbour after&#39;</span><span class="p">,</span><span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>                             
             <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
               <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::burp e2_ i_-&gt; i_+1&#39;</span><span class="p">)</span>
               
           <span class="k">if</span> <span class="n">j_</span> <span class="ow">in</span> <span class="n">lines_internal_nodes_</span><span class="p">[</span><span class="n">g_</span><span class="p">]</span> <span class="p">:</span>
             <span class="c1"># peut avoir ete change ... </span>
             <span class="k">try</span> <span class="p">:</span>
               <span class="n">idj_</span> <span class="o">=</span>  <span class="n">e2_</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">j_</span><span class="p">)</span>                            
               <span class="n">e2_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">idj_</span><span class="p">]</span> <span class="o">=</span> <span class="n">n2nn_</span><span class="p">[</span><span class="n">j_</span><span class="p">]</span>
               <span class="n">nj_</span> <span class="o">=</span> <span class="n">n2nn_</span><span class="p">[</span><span class="n">j_</span><span class="p">]</span>               
             <span class="k">except</span><span class="p">:</span>
               <span class="n">idj_</span> <span class="o">=</span> <span class="n">e2_</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n2nn_</span><span class="p">[</span><span class="n">j_</span><span class="p">])</span>
               <span class="c1"># on ne touche pas ni_ puisque deja modifie</span>
               
             <span class="c1"># on cherche l element voisins de e2_ : j_-1 -&gt; j_</span>
             <span class="n">jj_</span> <span class="o">=</span> <span class="n">e2_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">idj_</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">e2_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)]</span>
             <span class="c1"># si noeud deja modifie on recupere le precedent</span>
             <span class="k">if</span> <span class="n">jj_</span> <span class="o">&gt;</span> <span class="n">nbn_</span> <span class="p">:</span> <span class="n">jj_</span> <span class="o">=</span> <span class="n">nn2n_</span><span class="p">[</span><span class="n">jj_</span><span class="p">]</span>
             <span class="n">inter_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">node2ele_</span><span class="p">[</span><span class="n">jj_</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">node2ele_</span><span class="p">[</span><span class="n">j_</span><span class="p">])</span>
             <span class="c1"># len(inter)==1 c est e2             </span>
             <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
               <span class="n">e3_</span><span class="o">=</span> <span class="n">inter_</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
               <span class="k">if</span> <span class="n">e3_</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">e2_</span><span class="o">.</span><span class="n">number</span> <span class="p">:</span> <span class="n">e3_</span> <span class="o">=</span> <span class="n">inter_</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
               <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;neighbour before&#39;</span><span class="p">,</span><span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>               
               <span class="k">try</span> <span class="p">:</span> 
                 <span class="n">idj_</span> <span class="o">=</span> <span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">j_</span><span class="p">)</span>
                 <span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">idj_</span><span class="p">]</span> <span class="o">=</span> <span class="n">n2nn_</span><span class="p">[</span><span class="n">j_</span><span class="p">]</span>
               <span class="k">except</span> <span class="p">:</span>
                 <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">j_</span><span class="p">,</span><span class="s1">&#39; already changed in &#39;</span><span class="p">,</span> <span class="n">n2nn_</span><span class="p">[</span><span class="n">j_</span><span class="p">])</span>                   
                 <span class="k">pass</span>
               <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;neighbour after&#39;</span><span class="p">,</span><span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>               
             <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
               <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::burp e2_ j-1 -&gt; j_&#39;</span><span class="p">)</span> 
             
         <span class="c1"># sinon on change e1_  </span>
         <span class="k">else</span> <span class="p">:</span>
           <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;modifying e1_&#39;</span><span class="p">)</span>             

           <span class="k">if</span> <span class="n">i_</span> <span class="ow">in</span> <span class="n">lines_internal_nodes_</span><span class="p">[</span><span class="n">g_</span><span class="p">]</span> <span class="p">:</span>
             <span class="n">e1_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">idi_</span><span class="p">]</span> <span class="o">=</span> <span class="n">n2nn_</span><span class="p">[</span><span class="n">i_</span><span class="p">]</span>
             <span class="n">ni_</span><span class="o">=</span><span class="n">n2nn_</span><span class="p">[</span><span class="n">i_</span><span class="p">]</span>
             
             <span class="c1"># on cherche l element voisins de e1_ : i_-1 -&gt; i_</span>
             <span class="n">ii_</span> <span class="o">=</span> <span class="n">e1_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">idi_</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">e1_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)]</span>
             <span class="c1"># si noeud deja modifie on recupere le precedent</span>
             <span class="k">if</span> <span class="n">ii_</span> <span class="o">&gt;</span> <span class="n">nbn_</span> <span class="p">:</span> <span class="n">ii_</span> <span class="o">=</span> <span class="n">nn2n_</span><span class="p">[</span><span class="n">ii_</span><span class="p">]</span>
             <span class="n">inter_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">node2ele_</span><span class="p">[</span><span class="n">ii_</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">node2ele_</span><span class="p">[</span><span class="n">i_</span><span class="p">])</span>
             <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
               <span class="n">e3_</span><span class="o">=</span> <span class="n">inter_</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
               <span class="k">if</span> <span class="n">e3_</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">e1_</span><span class="o">.</span><span class="n">number</span> <span class="p">:</span> <span class="n">e3_</span> <span class="o">=</span> <span class="n">inter_</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
               <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;neighbour before &#39;</span><span class="p">,</span><span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>               
               <span class="k">try</span> <span class="p">:</span>
                 <span class="n">idi_</span> <span class="o">=</span> <span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i_</span><span class="p">)</span>
                 <span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">idi_</span><span class="p">]</span> <span class="o">=</span> <span class="n">n2nn_</span><span class="p">[</span><span class="n">i_</span><span class="p">]</span>
               <span class="k">except</span> <span class="p">:</span>
                 <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i_</span><span class="p">,</span><span class="s1">&#39; already changed in &#39;</span><span class="p">,</span> <span class="n">n2nn_</span><span class="p">[</span><span class="n">i_</span><span class="p">])</span>                   
                 <span class="k">pass</span>
               <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;neighbour after &#39;</span><span class="p">,</span><span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>                             
             <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
               <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::burp e1_ i_-1 -&gt; i_&#39;</span><span class="p">)</span> 
           
           <span class="k">if</span> <span class="n">j_</span> <span class="ow">in</span> <span class="n">lines_internal_nodes_</span><span class="p">[</span><span class="n">g_</span><span class="p">]</span> <span class="p">:</span>
             <span class="k">try</span><span class="p">:</span> 
               <span class="n">idj_</span> <span class="o">=</span>  <span class="n">e1_</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">j_</span><span class="p">)</span>
               <span class="n">e1_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">idj_</span><span class="p">]</span> <span class="o">=</span> <span class="n">n2nn_</span><span class="p">[</span><span class="n">j_</span><span class="p">]</span>
               <span class="n">nj_</span><span class="o">=</span><span class="n">n2nn_</span><span class="p">[</span><span class="n">j_</span><span class="p">]</span>
             <span class="k">except</span><span class="p">:</span>
               <span class="n">idj_</span> <span class="o">=</span> <span class="n">e1_</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n2nn_</span><span class="p">[</span><span class="n">j_</span><span class="p">])</span>
               <span class="c1"># on ne touche pas nj_ car deja change</span>
               
             <span class="c1"># on cherche l element voisins de e2_ : j_ -&gt; j_+1</span>
             <span class="n">jj_</span> <span class="o">=</span> <span class="n">e1_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">idj_</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">e1_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)]</span>
             <span class="c1"># si noeud deja modifie on recupere le precedent</span>
             <span class="k">if</span> <span class="n">jj_</span> <span class="o">&gt;</span> <span class="n">nbn_</span> <span class="p">:</span> <span class="n">jj_</span> <span class="o">=</span> <span class="n">nn2n_</span><span class="p">[</span><span class="n">jj_</span><span class="p">]</span>
             <span class="n">inter_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">node2ele_</span><span class="p">[</span><span class="n">jj_</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">node2ele_</span><span class="p">[</span><span class="n">j_</span><span class="p">])</span>
             <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
               <span class="n">e3_</span><span class="o">=</span> <span class="n">inter_</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
               <span class="k">if</span> <span class="n">e3_</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">e1_</span><span class="o">.</span><span class="n">number</span> <span class="p">:</span> <span class="n">e3_</span> <span class="o">=</span> <span class="n">inter_</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
               <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;neighbour before &#39;</span><span class="p">,</span><span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>
               <span class="k">try</span> <span class="p">:</span> 
                 <span class="n">idj_</span> <span class="o">=</span> <span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">j_</span><span class="p">)</span>
                 <span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">idj_</span><span class="p">]</span> <span class="o">=</span> <span class="n">n2nn_</span><span class="p">[</span><span class="n">j_</span><span class="p">]</span>
               <span class="k">except</span> <span class="p">:</span>
                 <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span>  <span class="nb">print</span><span class="p">(</span><span class="n">j_</span><span class="p">,</span><span class="s1">&#39; already changed in &#39;</span><span class="p">,</span> <span class="n">n2nn_</span><span class="p">[</span><span class="n">j_</span><span class="p">])</span>                                     
                 <span class="k">pass</span>
               <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;neighbour after &#39;</span><span class="p">,</span><span class="n">e3_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>                             
             <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
               <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::burp e1_ j_-&gt;j+1&#39;</span><span class="p">)</span> 

         <span class="n">seg</span> <span class="o">=</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                       <span class="n">connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">nj_</span><span class="p">,</span><span class="n">ni_</span><span class="p">],</span>
                       <span class="n">physicalEntity</span><span class="o">=</span><span class="n">grp_</span><span class="p">)</span>
         <span class="n">body</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>

         <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span>
           <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;after&#39;</span><span class="p">)</span>
           <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;e1_&#39;</span><span class="p">,</span><span class="n">e1_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>
           <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;e2_&#39;</span><span class="p">,</span><span class="n">e2_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>
           <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-----&#39;</span><span class="p">)</span>

   <span class="c1"># histoire que les nouveaux noeuds appartiennent a un groupe</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineGroups</span><span class="p">()</span>
         
   <span class="c1"># pour stocker les elements antagonistes</span>
   <span class="n">allines_</span><span class="o">=</span><span class="p">{}</span>
   <span class="k">for</span> <span class="n">grp_</span> <span class="ow">in</span> <span class="n">algrp_</span> <span class="p">:</span>
     <span class="k">if</span> <span class="n">grp_</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>  
       <span class="k">for</span> <span class="n">bulk_</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">grp_</span><span class="p">]</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">bulk_</span><span class="o">.</span><span class="n">nbNodes</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">:</span>
            <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D::dtc&#39;</span><span class="p">)</span> 
          <span class="n">allines_</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">grp_</span><span class="p">,[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bulk_</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
   <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span>     
     <span class="k">for</span> <span class="n">k_</span><span class="p">,</span><span class="n">v_</span> <span class="ow">in</span> <span class="n">allines_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;group &#39;</span><span class="p">,</span><span class="n">k_</span><span class="p">,</span><span class="s1">&#39; contains &#39;</span><span class="p">,</span><span class="n">v_</span><span class="p">)</span>
      
   <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--- managing corner nodes ---&#39;</span><span class="p">)</span>
   <span class="c1"># on construit en chaque coin les ensembles de noeuds connexes (les parts_)</span>
   <span class="k">for</span> <span class="n">corner_</span><span class="p">,</span><span class="n">clines_</span> <span class="ow">in</span> <span class="n">corners_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
     <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;corner node &#39;</span><span class="p">,</span><span class="n">corner_</span><span class="p">)</span> 
     <span class="n">nbe_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node2ele_</span><span class="p">[</span><span class="n">corner_</span><span class="p">])</span>
     <span class="n">parts_</span><span class="o">=</span><span class="p">{}</span>           
     <span class="c1"># pour savoir qui on a deja garde</span>
     <span class="n">etag_</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbe_</span><span class="p">)</span>
     <span class="c1"># un set de recherche</span>
     <span class="n">tosearch_</span><span class="o">=</span><span class="nb">set</span><span class="p">()</span>
     <span class="c1"># on recherche un noeuveau point de depart</span>
     <span class="k">for</span> <span class="n">id1_</span><span class="p">,</span><span class="n">e1_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node2ele_</span><span class="p">[</span><span class="n">corner_</span><span class="p">]):</span>
       <span class="k">if</span> <span class="n">etag_</span><span class="p">[</span><span class="n">id1_</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">:</span> <span class="k">continue</span>
       <span class="c1"># celui la est vu</span>
       <span class="n">etag_</span><span class="p">[</span><span class="n">id1_</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
       <span class="c1"># il devient la clef d&#39;une part</span>
       <span class="n">parts_</span><span class="p">[</span><span class="n">e1_</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
       <span class="c1"># il devient le point de depart de la recherche</span>
       <span class="n">tosearch_</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e1_</span><span class="p">)</span>
       
       <span class="c1"># on cherche ses voisins ou les voisins de ses voisins</span>
       <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">tosearch_</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">:</span>
         <span class="n">e_actif_</span> <span class="o">=</span> <span class="n">tosearch_</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
         <span class="c1"># recherche parmis tous</span>
         <span class="k">for</span> <span class="n">id2_</span><span class="p">,</span><span class="n">e2_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node2ele_</span><span class="p">[</span><span class="n">corner_</span><span class="p">])</span> <span class="p">:</span>
            <span class="c1"># si deja vu on passe</span>
            <span class="k">if</span> <span class="n">etag_</span><span class="p">[</span><span class="n">id2_</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">:</span> <span class="k">continue</span>
            <span class="c1"># combien de noeuds communs ?</span>
            <span class="n">inter_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">e_actif_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">e2_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>
                 
            <span class="c1"># cas pourri</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="p">:</span>
              <span class="n">showError</span><span class="p">(</span><span class="s1">&#39;crackMeshedAvatar2D:: in corner node element should share 1 or 2 nodes&#39;</span><span class="p">)</span>
                 
            <span class="c1"># partage un bord on ajoute a part_ et on le met dans le set de recherche</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
              <span class="n">parts_</span><span class="p">[</span><span class="n">e1_</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e2_</span><span class="p">)</span>
              <span class="c1"># declare vu</span>
              <span class="n">etag_</span><span class="p">[</span><span class="n">id2_</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
              <span class="c1"># point de depart de recherche</span>
              <span class="n">tosearch_</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e2_</span><span class="p">)</span>

     <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number of parts &#39;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">parts_</span><span class="p">))</span>

     <span class="c1"># on cherche les elements cl et al qui rayonnent sur le coin</span>
     <span class="c1">#... cl</span>
     <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;initial 1D elements&#39;</span><span class="p">)</span>
     <span class="n">adje_</span><span class="o">=</span><span class="p">[]</span>
     <span class="k">for</span> <span class="n">line_</span> <span class="ow">in</span> <span class="n">clines_</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ele_</span> <span class="ow">in</span> <span class="n">lines_</span><span class="p">[</span><span class="n">line_</span><span class="p">]:</span>
          <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">ele_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">corner_</span> <span class="ow">or</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">ele_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">corner_</span> <span class="p">:</span>
             <span class="n">adje_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ele_</span><span class="p">)</span>
     <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span>
       <span class="nb">print</span><span class="p">(</span><span class="n">adje_</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">seg_</span> <span class="ow">in</span> <span class="n">adje_</span><span class="p">:</span>
          <span class="nb">print</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">seg_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>
      
     <span class="c1">#... al</span>
     <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;opposite 1D elements &#39;</span><span class="p">)</span>     
     <span class="n">aladje_</span><span class="o">=</span><span class="p">[]</span>
     <span class="k">for</span> <span class="n">grp_</span> <span class="ow">in</span> <span class="n">algrp_</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">grp_</span> <span class="ow">in</span> <span class="n">allines_</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
          <span class="k">for</span> <span class="n">ele_</span> <span class="ow">in</span> <span class="n">allines_</span><span class="p">[</span><span class="n">grp_</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">ele_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">corner_</span> <span class="ow">or</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">ele_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">corner_</span> <span class="p">:</span>
               <span class="n">aladje_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ele_</span><span class="p">)</span>
     <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span>         
       <span class="nb">print</span><span class="p">(</span><span class="n">aladje_</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">seg_</span> <span class="ow">in</span> <span class="n">aladje_</span><span class="p">:</span>
          <span class="nb">print</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">seg_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>
        
     <span class="n">nbp_</span><span class="o">=</span><span class="mi">0</span>
     <span class="k">for</span> <span class="n">k_</span><span class="p">,</span><span class="n">v_</span> <span class="ow">in</span> <span class="n">parts_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">nbp_</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">bavard</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;part&#39;</span><span class="p">,</span><span class="n">nbp_</span><span class="p">,</span><span class="s1">&#39;has root element &#39;</span><span class="p">,</span><span class="n">k_</span><span class="o">.</span><span class="n">number</span><span class="p">,</span><span class="s1">&#39;which is linked to &#39;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">v_</span><span class="p">),</span><span class="s1">&#39; elements&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nbp_</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span> <span class="k">continue</span>
        <span class="n">coor_</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">corner_</span><span class="p">]</span><span class="o">.</span><span class="n">coor</span>
        <span class="n">nb_</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">body</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">coor</span><span class="o">=</span><span class="n">coor_</span><span class="p">,</span><span class="n">number</span><span class="o">=</span><span class="n">nb_</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">nb_</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">nb_</span><span class="p">]</span><span class="o">.</span><span class="n">dof</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">corner_</span><span class="p">]</span><span class="o">.</span><span class="n">dof</span>

        <span class="c1"># on modifie les segments</span>
        <span class="k">for</span> <span class="n">seg_</span> <span class="ow">in</span> <span class="n">adje_</span> <span class="p">:</span>
          <span class="c1"># avec root </span>
          <span class="n">inter_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">k_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">seg_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>
          <span class="c1"># le segment est bien appuye a cet element</span>
          <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
            <span class="n">id_</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">seg_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">corner_</span><span class="p">)</span>             
            <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">seg_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="n">nb_</span>
          <span class="c1"># avec les autres</span>
          <span class="k">for</span> <span class="n">e_</span> <span class="ow">in</span> <span class="n">v_</span><span class="p">:</span>
            <span class="n">inter_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">e_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">seg_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>
            <span class="c1"># le segment est bien appuye a cet element</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
              <span class="n">id_</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">seg_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">corner_</span><span class="p">)</span>             
              <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">seg_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="n">nb_</span>
            
        <span class="c1"># on modifie les segments antagonistes</span>
        <span class="k">for</span> <span class="n">seg_</span> <span class="ow">in</span> <span class="n">aladje_</span> <span class="p">:</span>
          <span class="n">inter_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">k_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">seg_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>
          <span class="c1"># print(k_.connectivity,len(inter_))</span>
          <span class="c1"># le segment est bien appuye a cet element</span>
          <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
            <span class="n">id_</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">seg_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">corner_</span><span class="p">)</span>             
            <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">seg_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="n">nb_</span>
          <span class="c1"># avec les autres</span>
          <span class="k">for</span> <span class="n">e_</span> <span class="ow">in</span> <span class="n">v_</span><span class="p">:</span>
            <span class="n">inter_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">e_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">seg_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span>
            <span class="c1"># print(e_.connectivity,len(inter_))            </span>
            <span class="c1"># le segment est bien appuye a cet element</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
              <span class="n">id_</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">seg_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">corner_</span><span class="p">)</span>             
              <span class="n">body</span><span class="o">.</span><span class="n">bulks</span><span class="p">[</span><span class="n">seg_</span><span class="p">]</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="n">nb_</span>

        <span class="c1"># on modifie les elements     </span>
        <span class="c1"># on modifie root         </span>
        <span class="n">id_</span> <span class="o">=</span> <span class="n">k_</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">corner_</span><span class="p">)</span>
        <span class="n">k_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="n">nb_</span>
        <span class="c1"># puis les autres elements de parts_</span>
        <span class="k">for</span> <span class="n">e_</span> <span class="ow">in</span> <span class="n">v_</span><span class="p">:</span>
          <span class="n">id_</span> <span class="o">=</span> <span class="n">e_</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">corner_</span><span class="p">)</span>
          <span class="n">e_</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="n">nb_</span>

          
   <span class="c1"># histoire que les nouveaux noeuds appartiennent a un groupe</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineGroups</span><span class="p">()</span>
          

   <span class="c1"># body.addContactors(group=crackgroup,shape=&#39;CLxxx&#39;,color=color,weights=w, reverse=&#39;yes&#39;)</span>

   <span class="c1"># roloc = list(color)</span>
   <span class="c1"># roloc = &quot;&quot;.join(roloc[::-1])</span>
   <span class="c1"># for grp_ in algrp_:</span>
   <span class="c1">#   body.addContactors(group=grp_,shape=&#39;ALpxx&#39;,color=roloc,reverse=&#39;yes&#39;) </span>
   
   <span class="k">return</span> <span class="n">body</span><span class="p">,</span><span class="n">algrp_</span></div>

<span class="c1"># fonction qui prend un maillage 2D et l&#39;eclate en rigides (polygones)</span>
<div class="viewcode-block" id="rigidsFromMesh2D"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.rigidsFromMesh2D">[docs]</a><span class="k">def</span> <span class="nf">rigidsFromMesh2D</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;BLUEx&#39;</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
   <span class="sd">&quot;&quot;&quot;rigidsFromMesh2D(surfacic_mesh, model, material, color=&#39;BLUEx&#39;, reverse=False, shrink=0.):</span>

<span class="sd">   this function build a set of rigids from a 2D mesh, each rigid</span>
<span class="sd">   is a polygon made from an element of the given mesh</span>

<span class="sd">   parameters:</span>

<span class="sd">   - surfacic_mesh: a 2D mesh</span>
<span class="sd">   - model: a given model</span>
<span class="sd">   - material: a given material</span>

<span class="sd">   optional parameter:</span>

<span class="sd">   - color=&#39;BLUEx&#39;: color of the polygon contactors</span>
<span class="sd">   - reverse=False: reverse=True iff the elements need to be reversed</span>
<span class="sd">   - shrink=0.: </span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="c1"># on verifie que l&#39;utilisateur a bien donne un maillage</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
      <span class="c1"># si ce n&#39;est pas le cas, on affiche un message d&#39;erreur</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given surfacic mesh is not a mesh!&quot;</span><span class="p">)</span>

   <span class="c1"># on verifie que le maillage est bien 2D</span>
   <span class="k">if</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
      <span class="c1"># si ce n&#39;est pas le cas, on affiche un message d&#39;erreur</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given mesh is not a surfacic mesh&quot;</span><span class="p">)</span>

   <span class="c1"># on declare un container d&#39;avatars pour stocker les rigides</span>
   <span class="n">bodies</span><span class="o">=</span><span class="n">avatars</span><span class="p">()</span>

   <span class="c1"># pour chaque element du maillage</span>
   <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si l&#39;element n&#39;est pas un triangle a 3 noeuds ou un quadrangle a quatre noeuds</span>
      <span class="k">if</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;T3xxx&#39;</span> <span class="ow">and</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;Q4xxx&#39;</span><span class="p">:</span>
         <span class="c1"># on passe au suivant</span>
         <span class="k">continue</span>

      <span class="c1"># on cree un avatar pour le nouveau rigide</span>
      <span class="n">body</span><span class="o">=</span><span class="n">avatar</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
      <span class="c1"># on cree un comportement volumique de type rigide</span>
      <span class="n">body</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">rigid2d</span><span class="p">()</span> <span class="p">)</span>
      <span class="c1"># on place le centre d&#39;inertie a l&#39;origine (recalcul de la position par la suite)</span>
      <span class="n">body</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span> <span class="n">node</span><span class="p">(</span> <span class="n">coor</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
      <span class="c1"># on definit les groupes sur le corps</span>
      <span class="n">body</span><span class="o">.</span><span class="n">defineGroups</span><span class="p">()</span>
      <span class="c1"># on affecte son modele au corps</span>
      <span class="n">body</span><span class="o">.</span><span class="n">defineModel</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span> 
      <span class="c1"># on affecte son materiau au corps</span>
      <span class="n">body</span><span class="o">.</span><span class="n">defineMaterial</span><span class="p">(</span><span class="n">material</span><span class="o">=</span><span class="n">material</span><span class="p">)</span>
      
      <span class="c1"># definition du contacteur polygone</span>
 
      <span class="c1"># on cree une liste pour stocker les coordonnees des neouds de l&#39;element courant</span>
      <span class="n">l_coor</span><span class="o">=</span><span class="p">[]</span>
      <span class="k">if</span> <span class="n">shrink</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="c1"># pour chaque noeud de l&#39;element</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
           <span class="c1"># on ajoute la position du noeud a la liste</span>
           <span class="n">l_coor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">coor</span><span class="p">)</span>

      <span class="k">else</span> <span class="p">:</span>
        <span class="c1"># pour chaque cote de l&#39;element on met 2 noeuds</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">):</span>
           <span class="n">ib</span> <span class="o">=</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
           <span class="n">ie</span> <span class="o">=</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)]</span>
           <span class="c1">#print ib,ie</span>
           <span class="n">coorb</span> <span class="o">=</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span><span class="o">.</span><span class="n">coor</span>
           <span class="n">coore</span> <span class="o">=</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">ie</span><span class="p">]</span><span class="o">.</span><span class="n">coor</span>
           <span class="c1">#print coorb,coore</span>
           <span class="n">v</span> <span class="o">=</span> <span class="n">coore</span> <span class="o">-</span> <span class="n">coorb</span>
           <span class="c1">#print v</span>

           <span class="n">shrk</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="mf">0.95</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.95</span><span class="p">)</span><span class="o">*</span><span class="n">shrink</span>  
           <span class="c1"># on ajoute la position du noeud a la liste</span>
           <span class="n">coor</span> <span class="o">=</span> <span class="n">coorb</span> <span class="o">+</span> <span class="n">shrk</span><span class="o">*</span><span class="n">v</span>
           <span class="c1">#print coor</span>
           <span class="n">l_coor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
           <span class="c1"># on ajoute la position du noeud a la liste</span>
           <span class="n">coor</span> <span class="o">=</span> <span class="n">coorb</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">shrk</span><span class="p">)</span><span class="o">*</span><span class="n">v</span>
           <span class="c1">#print coor</span>
           <span class="n">l_coor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span>
              
      <span class="c1"># si on doit retourner l&#39;element pour que son orientation soit correcte</span>
      <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
         <span class="c1"># on inverse la liste des coordonnees des noeuds de l&#39;element</span>
         <span class="n">l_coor</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
      <span class="c1"># on ajoute son contacteur polygone au corps</span>
      <span class="n">body</span><span class="o">.</span><span class="n">addContactors</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="s1">&#39;POLYG&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">nb_vertices</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">l_coor</span><span class="p">),</span> <span class="n">vertices</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l_coor</span><span class="p">))</span>

      <span class="c1"># on calcule de la surface et de l&#39;inertie du corps</span>
      <span class="n">body</span><span class="o">.</span><span class="n">computeRigidProperties</span><span class="p">()</span>

      <span class="c1"># on ajoute le corps rigide a la liste des corps</span>
      <span class="n">bodies</span><span class="o">.</span><span class="n">addAvatar</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>

   <span class="c1"># on renvoie la liste des corps generee</span>
   <span class="k">return</span> <span class="n">bodies</span></div>

<span class="c1"># fonction qui prend un maillage 2D et cree un corps rigide comme un cluster de polygones (chaque maille devenant un contacteur)</span>
<div class="viewcode-block" id="rigidFromMesh2D"><a class="viewcode-back" href="../../../../pre_classes.html#pylmgc90.pre.rigidFromMesh2D">[docs]</a><span class="k">def</span> <span class="nf">rigidFromMesh2D</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;BLUEx&#39;</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
   <span class="sd">&quot;&quot;&quot;rigidFromMesh2D(surfacic_mesh, model, material, color=&#39;BLUEx&#39;, reverse=False):</span>

<span class="sd">   this function build a rigid from a 2D mesh, each contactor</span>
<span class="sd">   is a polygon made from an element of the given mesh</span>

<span class="sd">   parameters:</span>

<span class="sd">   - surfacic_mesh: a 2D mesh</span>
<span class="sd">   - model: a given model</span>
<span class="sd">   - material: a given material</span>

<span class="sd">   optional parameter:</span>

<span class="sd">   - color=&#39;BLUEx&#39;: color of the polygon contactors</span>
<span class="sd">   - reverse=False: reverse=True iff the elements need to be reversed</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="c1"># on verifie que l&#39;utilisateur a bien donne un maillage</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
      <span class="c1"># si ce n&#39;est pas le cas, on affiche un message d&#39;erreur</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given surfacic mesh is not a mesh!&quot;</span><span class="p">)</span>

   <span class="c1"># on verifie que le maillage est bien 2D</span>
   <span class="k">if</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
      <span class="c1"># si ce n&#39;est pas le cas, on affiche un message d&#39;erreur</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given mesh is not a surfacic mesh&quot;</span><span class="p">)</span>

   <span class="c1"># on cree un avatar pour le nouveau rigide</span>
   <span class="n">body</span><span class="o">=</span><span class="n">avatar</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
   <span class="c1"># on cree un comportement volumique de type rigide</span>
   <span class="n">body</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">rigid2d</span><span class="p">()</span> <span class="p">)</span>
   <span class="c1"># on place le centre d&#39;inertie a l&#39;origine (recalcul de la position par la suite)</span>
   <span class="n">body</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span> <span class="n">node</span><span class="p">(</span> <span class="n">coor</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
   <span class="c1"># on definit les groupes sur le corps</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineGroups</span><span class="p">()</span>
   <span class="c1"># on affecte son modele au corps</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineModel</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span> 
   <span class="c1"># on affecte son materiau au corps</span>
   <span class="n">body</span><span class="o">.</span><span class="n">defineMaterial</span><span class="p">(</span><span class="n">material</span><span class="o">=</span><span class="n">material</span><span class="p">)</span>
 
   <span class="c1"># pour chaque element du maillage</span>
   <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si l&#39;element n&#39;est pas un triangle a 3 noeuds ou un quadrangle a quatre noeuds</span>
      <span class="k">if</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;T3xxx&#39;</span> <span class="ow">and</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">!=</span> <span class="s1">&#39;Q4xxx&#39;</span><span class="p">:</span>
         <span class="c1"># on passe au suivant</span>
         <span class="k">continue</span>
     
      <span class="c1"># definition d&#39;un nouveau contacteur polygone</span>
 
      <span class="c1"># on cree une liste pour stocker les coordonnees des neouds de l&#39;element courant</span>
      <span class="n">l_coor</span><span class="o">=</span><span class="p">[]</span>
      <span class="c1"># pour chaque noeud de l&#39;element</span>
      <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
         <span class="c1"># on ajoute la position du noeud a la liste</span>
         <span class="n">l_coor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">surfacic_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">coor</span><span class="p">)</span>
      <span class="c1"># si on doit retourner l&#39;element pour que son orientation soit correcte</span>
      <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
         <span class="c1"># on inverse la liste des coordonnees des noeuds de l&#39;element</span>
         <span class="n">l_coor</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
      <span class="c1"># on ajoute son contacteur polygone au corps</span>
      <span class="n">body</span><span class="o">.</span><span class="n">addContactors</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="s1">&#39;POLYG&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">nb_vertices</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">l_coor</span><span class="p">),</span> <span class="n">vertices</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l_coor</span><span class="p">))</span>

   <span class="c1"># on calcule de la surface et de l&#39;inertie du corps</span>
   <span class="n">body</span><span class="o">.</span><span class="n">computeRigidProperties</span><span class="p">()</span>

   <span class="c1"># on renvoie le corps generee</span>
   <span class="k">return</span> <span class="n">body</span></div>

<span class="c1"># fonction qui extrait le contour libre d&#39;un maillage 2D surfacique, sous la forme d&#39;un maillage 2D lineique</span>
<span class="c1"># N.B.: les numeros des noeuds du maillage surfacique ne sont pas renumerotes</span>
<span class="k">def</span> <span class="nf">extractContour</span><span class="p">(</span><span class="n">given_mesh</span><span class="p">):</span>
   <span class="sd">&quot;&quot;&quot;extractContour(given_m):</span>

<span class="sd">   this function computes and returns the contour of a surfacic mesh, as a</span>
<span class="sd">   lineic mesh.</span>

<span class="sd">   N.B.: this function handles triangles and quadrilaterals</span>

<span class="sd">   parameters:</span>

<span class="sd">   - given_mesh: the given mesh</span>

<span class="sd">   returned value: the built lineic mesh</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="c1"># si le maillage donne n&#39;est pas un maillage</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">given_mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
      <span class="c1"># on affiche un message d&#39;erreur</span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given mesh is not a mesh&quot;</span><span class="p">)</span>

   <span class="c1"># si le maillage n&#39;est pas defini avec des noeuds a deux dimensions</span>
   <span class="k">if</span> <span class="n">given_mesh</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
      <span class="c1"># ca ne peut pas etre un maillage surfacique !</span>
      <span class="c1"># on affiche un message d&#39;erreur </span>
      <span class="n">showError</span><span class="p">(</span><span class="s2">&quot;the given mesh is not 2D !&quot;</span><span class="p">)</span>

   <span class="c1"># numerotation des elements</span>

   <span class="c1"># on enumere les elements</span>
   <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">given_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">):</span>
      <span class="c1"># on affecte l&#39;indice courant a l&#39;element courant</span>
      <span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="o">=</span><span class="n">num</span>

   <span class="c1"># construction des listes d&#39;adjacence de chaque noeud</span>

   <span class="c1"># on definit un container pour stocker les listes d&#39;adjacence de chaque noeud </span>
   <span class="n">l_node2ele</span> <span class="o">=</span> <span class="p">{}</span>
   <span class="c1"># pour chaque noeud du corps, on intialise une liste d&#39;adjacence vide</span>
   <span class="k">for</span> <span class="n">nod</span> <span class="ow">in</span> <span class="n">given_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
      <span class="n">l_node2ele</span><span class="p">[</span><span class="n">nod</span><span class="o">.</span><span class="n">number</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
   <span class="c1"># pour chaque element du maillage </span>
   <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="n">given_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># pour chaque noeud de l&#39;element</span>
      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
         <span class="c1"># on ajoute l&#39;element courant dans la liste d&#39;adjacence du noeud courant</span>
         <span class="n">l_node2ele</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bulk</span><span class="p">)</span>
 
   <span class="c1">###for nod in given_mesh.nodes:</span>
   <span class="c1">###  print &#39;noeuds &#39;,nod.number,&#39; nombre de voisins &#39;,len(l_node2ele[nod.number])</span>

       
   <span class="c1"># extraction de la surface libre</span>
   
   <span class="c1"># on definit la liste du nombre de bords n&#39;appartenant pas au contour pour chaque element </span>
   <span class="n">nb_non_free_faces</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">given_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">),</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span>
   <span class="c1"># on definit le dictionnaire qui indique pour chaque element, identifie par son numero, quel bord est libre</span>
   <span class="n">is_free_face</span><span class="o">=</span><span class="p">{}</span>
   <span class="c1"># pour chaque element</span>
   <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="n">given_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si l&#39;element est un element surfacique</span>
      <span class="k">if</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
         <span class="c1"># si l&#39;element est un triangle</span>
         <span class="k">if</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;T3xxx&#39;</span><span class="p">:</span> <span class="c1"># ca pourrait etre T6xxx aussi ...</span>
            <span class="c1"># on suppose que tous les bords sont sur le contour</span>
            <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>

            <span class="c1"># on recupere les numeros des noeuds du tetraedre</span>
            <span class="n">i1</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i2</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">i3</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1">###print &#39;on teste ele&#39;,bulk.number,&#39; noeuds &#39;,i1,i2,i3</span>

            <span class="c1"># on teste d&#39;abord les faces qui portent le noeud i1 de l&#39;element courant</span>
            <span class="c1"># pour chaque element adjacent au noeud i1</span>
            <span class="k">for</span> <span class="n">adj_bulk</span> <span class="ow">in</span> <span class="n">l_node2ele</span><span class="p">[</span><span class="n">i1</span><span class="p">]:</span>
               <span class="c1">###print adj_bulk.number, adj_bulk.type, adj_bulk.connectivity</span>

               <span class="c1"># si l&#39;element adjacent courant est l&#39;element courant</span>
               <span class="k">if</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">:</span>
                  <span class="c1"># on passe au suivant</span>
                  <span class="k">continue</span>

               <span class="c1"># si l&#39;element courant n&#39;est pas un element surfacique</span>
               <span class="k">if</span> <span class="ow">not</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                  <span class="c1"># on passe au suivant</span>
                  <span class="k">continue</span>

               <span class="c1">###print  &#39;voisin &#39;,adj_bulk.number,&#39; noeuds &#39;,adj_bulk.connectivity</span>
               <span class="c1"># si le bord 0 {i1, i2} fait partie de l&#39;adjacent</span>
               <span class="k">if</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span> <span class="p">:</span>
                  <span class="c1"># on vire </span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de bords de l&#39;ele qui n&#39;appartiennent pas au contour</span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

               <span class="c1"># si le bord 2 {i3,i1} fait partie de l&#39;adjacent</span>
               <span class="k">if</span> <span class="n">i3</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                  <span class="c1"># on vire </span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de bords de l&#39;ele qui n&#39;appartiennent pas au contour </span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># pour chaque element adjacent au noeud i2</span>
            <span class="k">for</span> <span class="n">adj_bulk</span> <span class="ow">in</span> <span class="n">l_node2ele</span><span class="p">[</span><span class="n">i2</span><span class="p">]:</span>
               <span class="c1"># si l&#39;element adjacent courant est l&#39;element courant</span>
               <span class="k">if</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">:</span>
                  <span class="c1"># on passe au suivant</span>
                  <span class="k">continue</span>
               <span class="c1"># si l&#39;element courant n&#39;est pas un element surfacique</span>
               <span class="k">if</span> <span class="ow">not</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                  <span class="c1"># on passe au suivant</span>
                  <span class="k">continue</span>

               <span class="c1"># si le bord 1 {i2, i3} fait partie de l&#39;adjacent</span>
               <span class="k">if</span> <span class="n">i3</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                  <span class="c1"># on vire </span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de bords de l&#39;ele qui n&#39;appartiennent pas au contour</span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

         <span class="k">elif</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;Q4xxx&#39;</span><span class="p">:</span>

            <span class="c1"># on suppose que tous les bords sont sur le contour</span>
            <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span>
            <span class="c1"># on recupere les numeros des noeuds</span>
            <span class="n">i1</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i2</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">i3</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">i4</span><span class="o">=</span><span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

            <span class="c1"># pour chaque element adjacent au noeud i1</span>
            <span class="k">for</span> <span class="n">adj_bulk</span> <span class="ow">in</span> <span class="n">l_node2ele</span><span class="p">[</span><span class="n">i1</span><span class="p">]:</span>
               <span class="c1"># si l&#39;element adjacent courant est l&#39;element courant</span>
               <span class="k">if</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">:</span>
                  <span class="c1"># on passe au suivant</span>
                  <span class="k">continue</span>
                              
               <span class="c1"># si l&#39;element courant n&#39;est pas un element surfacique</span>
               <span class="k">if</span> <span class="ow">not</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">:</span>
                  <span class="k">continue</span>

               <span class="c1"># si le bord 0 {i1, i2} fait partie de l&#39;adjacent</span>
               <span class="k">if</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                  <span class="c1"># on vire</span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de bords de l&#39;ele qui n&#39;appartiennent pas au contour</span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                  
               <span class="c1"># si le bord 3 {i4, i1} fait partie de l&#39;adjacent</span>
               <span class="k">if</span> <span class="n">i4</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span> <span class="p">:</span>
                  <span class="c1"># on vire</span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de bords de l&#39;ele qui n&#39;appartiennent pas au contour</span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># pour chaque element adjacent au noeud i3</span>
            <span class="k">for</span> <span class="n">adj_bulk</span> <span class="ow">in</span> <span class="n">l_node2ele</span><span class="p">[</span><span class="n">i3</span><span class="p">]:</span>
               <span class="c1"># si l&#39;element adjacent courant est l&#39;element courant</span>
               <span class="k">if</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">:</span>
                  <span class="c1"># on passe au suivant</span>
                  <span class="k">continue</span>

               <span class="c1"># si l&#39;element courant n&#39;est pas un tetraedre</span>
               <span class="k">if</span> <span class="ow">not</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                  <span class="c1"># on passe au suivant</span>
                  <span class="k">continue</span>

               <span class="c1"># si le bord 1 {i2, i3} fait partie de l&#39;adjacent</span>
               <span class="k">if</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span> <span class="p">:</span>
                  <span class="c1"># on vire</span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de bords de l&#39;ele qui n&#39;appartiennent pas au contour</span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

               <span class="c1"># si le bord 2 {i3, i4} fait partie de l&#39;adjacent courant</span>
               <span class="k">if</span> <span class="n">i4</span> <span class="ow">in</span> <span class="n">adj_bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
                  <span class="c1"># on vire</span>
                  <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                  <span class="c1"># on incremente le nombre de bords de l&#39;ele qui n&#39;appartiennent pas au contour</span>
                  <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

         <span class="c1"># si l&#39;element n&#39;est pas gere</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="c1">## on quitte le pgm</span>
            <span class="n">msg</span>  <span class="o">=</span> <span class="s2">&quot;no contour can be built from this mesh, since it involves unhandled elements!&quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">+</span> <span class="s1">&#39; is not supported&#39;</span>
            <span class="n">showError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

   <span class="c1"># ici, on est sur que tous les elements du maillage sont pris en charge</span>

   <span class="c1"># on declare un maillage pour stocker le maillage du contour</span>
   <span class="c1"># N.B.: le maillage est defini avec des noeuds a deux dimensions, meme s&#39;il ne contient que des elements lineiques</span>

   <span class="n">contour</span><span class="o">=</span><span class="n">mesh</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

   <span class="c1"># recuperation des elements du contour</span>

   <span class="c1"># pour chaque element</span>
   <span class="k">for</span> <span class="n">bulk</span> <span class="ow">in</span> <span class="n">given_mesh</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># si element surfacique </span>
      <span class="k">if</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="ow">in</span> <span class="n">dimension2geoElement</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
         <span class="c1">###print nb_non_free_faces[bulk.number]</span>
         <span class="c1"># si l&#39;element est un tetraedre</span>
         <span class="k">if</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;T3xxx&#39;</span><span class="p">:</span>
            <span class="n">nbn</span><span class="o">=</span><span class="mi">3</span> <span class="c1"># 0-&gt;2</span>
            <span class="c1"># si aucun bord libre</span>
            <span class="k">if</span> <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
               <span class="c1"># on passe a l&#39;element suivant</span>
               <span class="k">continue</span>
         <span class="k">elif</span> <span class="n">bulk</span><span class="o">.</span><span class="n">etype</span> <span class="o">==</span> <span class="s1">&#39;Q4xxx&#39;</span><span class="p">:</span>
            <span class="n">nbn</span><span class="o">=</span><span class="mi">4</span> <span class="c1"># 0-&gt;3</span>
            <span class="c1"># si aucun bord libre</span>
            <span class="k">if</span> <span class="n">nb_non_free_faces</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
               <span class="c1"># on passe a l&#39;element suivant</span>
               <span class="k">continue</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="c1"># connait pas</span>
            <span class="c1"># on passe a l&#39;element suivant</span>
            <span class="k">continue</span>

         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">])):</span>                       
           <span class="c1"># si la face courante est libre</span>
           <span class="k">if</span> <span class="n">is_free_face</span><span class="p">[</span><span class="n">bulk</span><span class="o">.</span><span class="n">number</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
             <span class="c1">###print bulk.number,bulk.etype,nbn,&#39; bord &#39;,i,(i+1)%nbn</span>
             <span class="c1"># on recupere la connectivite de la face</span>
             <span class="n">bord</span><span class="o">=</span><span class="p">[</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">,</span> <span class="n">bulk</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">nbn</span><span class="p">]]</span>
             <span class="c1"># on ajoute le bord au contour</span>
             <span class="n">contour</span><span class="o">.</span><span class="n">addBulk</span><span class="p">(</span> <span class="n">element</span><span class="p">(</span><span class="n">elem_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">bord</span><span class="p">)</span> <span class="p">)</span>
                      
   <span class="c1"># recuperation des noeuds du contour</span>

   <span class="c1"># on declare la liste des numeros de noeuds du contour</span>
   <span class="n">free_node_numbers</span><span class="o">=</span><span class="p">[]</span>
   <span class="c1"># pour chaque bord du contour</span>
   <span class="k">for</span> <span class="n">bord</span> <span class="ow">in</span> <span class="n">contour</span><span class="o">.</span><span class="n">bulks</span><span class="p">:</span>
      <span class="c1"># pour chaque noeud de la table de connectivite de la face</span>
      <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="n">bord</span><span class="o">.</span><span class="n">connectivity</span><span class="p">:</span>
         <span class="c1"># si le noeud n&#39;a pas deja ete visite</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">number</span> <span class="ow">in</span> <span class="n">free_node_numbers</span><span class="p">:</span>
            <span class="c1"># on ajoute le numero du noeud courant a la liste des numeors de noeuds de la surface libre</span>
            <span class="n">free_node_numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
            <span class="c1"># on ajoute une copie du noeud au maillage de la surface libre</span>
            <span class="n">contour</span><span class="o">.</span><span class="n">addNode</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">given_mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">number</span><span class="p">]))</span>

   <span class="c1">###sys.exit()</span>
   <span class="c1"># on renvoie le maillage du contour</span>
   <span class="k">return</span> <span class="n">contour</span>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pylmgc90 2025.rc1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pylmgc90.pre.build_avatar.mesh2D</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2025, CNRS, UM.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>